"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerRecordActionDataCallback = registerRecordActionDataCallback;
exports.__injectSdkIntoPerformRecordAction = __injectSdkIntoPerformRecordAction;
exports.PerformRecordAction = exports.WatchablePerformRecordActionKeys = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error_utils = require("./error_utils");

var _abstract_model_with_async_data = _interopRequireDefault(require("./models/abstract_model_with_async_data"));

var _private_utils = require("./private_utils");

/** @hidden */
var WatchablePerformRecordActionKeys = Object.freeze({
  // isDataLoaded must be a watchable key for a LoadableModel.
  isDataLoaded: 'isDataLoaded',
  recordActionData: 'recordActionData'
});
/** @hidden */

exports.WatchablePerformRecordActionKeys = WatchablePerformRecordActionKeys;

/**
 * This class exists to manage registering a callback to receive "Open block" / "Perform record
 * action" messages.
 * This is different to other message handlers (_registerHandlers) since the callback is specified
 * by the block: it registers it during first render (vs the SDK registering during initialisation).
 *
 * On the liveapp side, we ensure that pending messages are held until the block registers the
 * callback (or another message is sent). If there's a pending message, it is returned at
 * registration.
 *
 * This class implements AbstractModelWithAsyncData in order to take advantage of useLoadable's
 * suspense handling. "Loading" the model means registering the handler with liveapp. This allows us
 * to suspend the block and return the initial pending message on first render.
 *
 * One difference is that _unloadData will not unregister the airtableInterface handler. We don't
 * support unregistering it at this time for simplicity.
 *
 * This class is internal: users should use registerRecordActionDataCallback or useRecordActionData.
 *
 * @internal
 * */
var PerformRecordAction =
/*#__PURE__*/
function (_AbstractModelWithAsy) {
  (0, _inherits2.default)(PerformRecordAction, _AbstractModelWithAsy);

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * The data from the latest record action, or null if none have occurred yet.
   *
   * @internal */

  /** @hidden */
  function PerformRecordAction(sdk, airtableInterface) {
    var _this;

    (0, _classCallCheck2.default)(this, PerformRecordAction);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PerformRecordAction).call(this, sdk, 'performRecordAction'));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_hasRegisteredHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_hasCompletedInitialDataLoad", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "recordActionData", void 0);
    _this._airtableInterface = airtableInterface;
    _this._hasRegisteredHandler = false;
    _this._hasCompletedInitialDataLoad = false;
    _this.recordActionData = null;
    _this._handlePerformRecordAction = _this._handlePerformRecordAction.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  /** @internal */


  (0, _createClass2.default)(PerformRecordAction, [{
    key: "_handlePerformRecordAction",

    /** @hidden */
    value: function _handlePerformRecordAction(data) {
      this.recordActionData = data;

      this._onChange(WatchablePerformRecordActionKeys.recordActionData, data);
    }
    /**
     * This accessor method is defined solely to satisfy the contract of the
     * AbstractModel class.
     *
     * @internal */

  }, {
    key: "_onChangeIsDataLoaded",

    /**
     * AbstractModelWithAsyncData implementation
     */

    /** @internal */
    value: function _onChangeIsDataLoaded() {
      this._onChange(WatchablePerformRecordActionKeys.isDataLoaded); // Handle the case where there was a pending action whilst we were registering the handler.
      // We only want to do this on the very initial load when we're actually registering the
      // handler: avoid triggering this when the data is "unloaded" and "loaded".


      if (!this._hasCompletedInitialDataLoad) {
        this._hasCompletedInitialDataLoad = true;

        if (this.recordActionData) {
          this._handlePerformRecordAction(this.recordActionData);
        }
      }
    }
    /** @internal */

  }, {
    key: "_loadDataAsync",
    value: function _loadDataAsync() {
      return _regenerator.default.async(function _loadDataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (this._hasRegisteredHandler) {
                _context.next = 5;
                break;
              }

              this._hasRegisteredHandler = true;
              _context.next = 4;
              return _regenerator.default.awrap(this._airtableInterface.fetchAndSubscribeToPerformRecordActionAsync(this._handlePerformRecordAction));

            case 4:
              this.recordActionData = _context.sent;

            case 5:
              return _context.abrupt("return", []);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /** @internal */

  }, {
    key: "_unloadData",
    value: function _unloadData() {} // Hack: Don't do anything, since "loading" means registering a handler, and we don't need
    // to unregister it.

    /** @internal */

  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return (0, _error_utils.invariant)(false, 'The `data` property of PerformRecordAction should not be referenced');
    }
    /**
     * This accessor method is defined because the parent implementation uses _dataOrNullIfDeleted
     *
     * @inheritdoc */

  }, {
    key: "isDeleted",
    get: function get() {
      return false;
    }
  }], [{
    key: "_isWatchableKey",
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchablePerformRecordActionKeys, key);
    }
  }, {
    key: "_shouldLoadDataForKey",
    value: function _shouldLoadDataForKey(key) {
      // Watching recordActionData will load data (aka register handler with liveapp) and trigger
      // callback when done.
      return key === WatchablePerformRecordActionKeys.recordActionData;
    }
  }]);
  return PerformRecordAction;
}(_abstract_model_with_async_data.default);
/**
 * Registers a callback to handle "open block" / "perform record action" events (from button field).
 *
 * Returns a unsubscribe function that should be used to unregister the callback for cleanup on
 * component unmount, or if you wish to register a different function.
 *
 * Also see {@link useRecordActionData}, which subscribes to the same events in a synchronous way.
 *
 * Your block will not receive "perform record action" events until a callback is registered -
 * they're held until registration to ensure the block is ready to handle the event (e.g. has
 * finished loading).
 *
 * Because of this, we recommend only registering a callback once, in your top level component -
 * otherwise, messages could be received while not all callbacks have been successfully registered.
 * Similarly, using both `registerRecordActionDataCallback` and `useRecordActionData` is not
 * supported.
 *
 * You can test your block in development by sending "perform record action" events to your block
 * in the "Advanced" panel of the block developer tools.
 *
 * After releasing your block, you can use it with a button field by choosing the "Open custom
 * block" action and selecting your block.
 *
 * @example
 * ```js
 * import React, {useEffect, useState} from 'react';
 * import {registerRecordActionDataCallback} from '@airtable/blocks/ui';
 *
 * function LatestRecordAction() {
 *     const [recordActionData, setRecordActionData] = useState(null);
 *
 *     const callback = (data) => {
 *         console.log('Record action received', data);
 *         setRecordActionData(data);
 *     }
 *
 *     useEffect(() => {
 *         // Return the unsubscribe function so it's run on cleanup.
 *         return registerRecordActionDataCallback(callback);
 *     }, [callback]);
 *
 *     if (recordActionData === null) {
 *         return <span>No events yet</span>;
 *     }
 *
 *     return (
 *         <ul>
 *             <li>Record id: {recordActionData.recordId}</li>
 *             <li>View id: {recordActionData.viewId}</li>
 *             <li>Table id: {recordActionData.tableId}</li>
 *         </ul>
 *     );
 * }
 * ```
 *
 */


exports.PerformRecordAction = PerformRecordAction;

function registerRecordActionDataCallback(callback) {
  var _sdk2 = sdk,
      performRecordAction = _sdk2.performRecordAction;

  var wrappedCallback = (model, key, data) => {
    callback(data);
  };

  performRecordAction.watch(WatchablePerformRecordActionKeys.recordActionData, wrappedCallback);
  return () => performRecordAction.unwatch(WatchablePerformRecordActionKeys.recordActionData, wrappedCallback);
}

var sdk; // The application-level Sdk instance must be injected dynamically to avoid
// circular dependencies at the time of module resolution.

function __injectSdkIntoPerformRecordAction(_sdk) {
  sdk = _sdk;
}