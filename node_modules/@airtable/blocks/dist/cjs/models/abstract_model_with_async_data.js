"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

/** @module @airtable/blocks/models: Abstract models */

/** */

/**
 * Abstract superclass for all Blocks SDK models that need to fetch async data.
 *
 * @docsPath models/advanced/AbstractModelWithAsyncData
 */
var AbstractModelWithAsyncData =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(AbstractModelWithAsyncData, _AbstractModel);
  (0, _createClass2.default)(AbstractModelWithAsyncData, null, [{
    key: "_shouldLoadDataForKey",

    /** @internal */

    /** @internal */
    value: function _shouldLoadDataForKey(key) {
      // Override to return whether watching the key should trigger the
      // data to be loaded for this model.
      return false;
    }
    /** @internal */

  }]);

  /** @hidden */
  function AbstractModelWithAsyncData(sdk, modelId) {
    var _this;

    (0, _classCallCheck2.default)(this, AbstractModelWithAsyncData);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(AbstractModelWithAsyncData).call(this, sdk, modelId));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_isDataLoaded", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_pendingDataLoadPromise", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_dataRetainCount", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_unloadDataTimeoutId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_isForceUnloaded", false);
    _this._isDataLoaded = false;
    _this._pendingDataLoadPromise = null;
    _this._dataRetainCount = 0;
    _this._unloadDataTimeoutId = null;
    return _this;
  }
  /**
   * Watching a key that needs to load data asynchronously will automatically
   * cause the data to be fetched. Once the data is available, the callback
   * will be called.
   *
   * @inheritdoc
   */


  (0, _createClass2.default)(AbstractModelWithAsyncData, [{
    key: "watch",
    value: function watch(keys, callback, context) {
      this._assertNotForceUnloaded();

      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(AbstractModelWithAsyncData.prototype), "watch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = validKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (this.constructor._shouldLoadDataForKey(key)) {
            // Note: for simplicity, we will call loadData for every key that needs
            // needs data, relying on the retain count to unload once all keys have
            // been unwatched.
            (0, _private_utils.fireAndForgetPromise)(this.loadDataAsync.bind(this));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return validKeys;
    }
    /**
     * Unwatching a key that needs to load data asynchronously will automatically
     * cause the data to be released. Once the data is available, the callback
     * will be called.
     *
     * @inheritdoc
     */

  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(AbstractModelWithAsyncData.prototype), "unwatch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = validKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          if (this.constructor._shouldLoadDataForKey(key)) {
            // We called loadDataAsync for every key that needs data so call
            // unloadData for every key to balance the retain count.
            this.unloadData();
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return validKeys;
    }
    /** @inheritdoc */

  }, {
    key: "loadDataAsync",
    // Override this method if your model is dependent on other models.
    // Do NOT load other models' data from _loadDataAsync, since it can lead to
    // unexpected behavior.
    // IMPORTANT: always call super.loadDataAsync() from your override.

    /**
     * Will cause all the async data to be fetched and retained. Every call to
     * `loadDataAsync` should have a matching call to `unloadData`.
     *
     * Returns a Promise that will resolve once the data is loaded.
     */
    value: function loadDataAsync() {
      return _regenerator.default.async(function loadDataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._assertNotForceUnloaded();

              if (this._unloadDataTimeoutId !== null) {
                // If we set a timeout to unload data, clear it since we are incrementing
                // the retain count and loading data.
                clearTimeout(this._unloadDataTimeoutId);
                this._unloadDataTimeoutId = null;
              } // We keep a count of how many things have loaded the data so we don't
              // actually unload the data until the retain count comes back down to zero.


              this._dataRetainCount++;

              if (!this._isDataLoaded) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return");

            case 5:
              if (!this._pendingDataLoadPromise) {
                this._pendingDataLoadPromise = this._loadDataAsync().then(changedKeys => {
                  this._isDataLoaded = true;
                  this._pendingDataLoadPromise = null;
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = changedKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var key = _step3.value;

                      this._onChange(key);
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }

                  this._onChangeIsDataLoaded();

                  return changedKeys;
                });
              }

              _context.next = 8;
              return _regenerator.default.awrap(this._pendingDataLoadPromise);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    } // Override this method if your model is dependent on other models.
    // Do NOT unload other models' data from _unloadData, since it can lead to
    // unexpected behavior.
    // IMPORTANT: always call super.unloadData() from your override.

    /** */

  }, {
    key: "unloadData",
    value: function unloadData() {
      if (this._isForceUnloaded) {
        return;
      }

      this._dataRetainCount--;

      if (this._dataRetainCount < 0) {
        console.warn("Block ".concat(this.constructor._className, " data over-released")); // eslint-disable-line no-console

        this._dataRetainCount = 0;
      }

      if (this._dataRetainCount === 0) {
        // Don't unload immediately. Wait a while in case something else
        // requests the data, so we can avoid going back to liveapp or
        // the network.
        this._unloadDataTimeoutId = setTimeout(() => {
          (0, _error_utils.invariant)(this._dataRetainCount === 0, 'Unload data timeout fired with non-zero retain count'); // Set _isDataLoaded to false before calling _unloadData in case
          // _unloadData reads from isDataLoaded.

          this._isDataLoaded = false;

          this._unloadData();

          this._onChangeIsDataLoaded();
        }, AbstractModelWithAsyncData.__DATA_UNLOAD_DELAY_MS);
      }
    }
  }, {
    key: "_forceUnload",
    value: function _forceUnload() {
      while (this._dataRetainCount > 0) {
        this.unloadData();
      }

      this._isForceUnloaded = true;
    }
  }, {
    key: "_assertNotForceUnloaded",
    value: function _assertNotForceUnloaded() {
      (0, _error_utils.invariant)(!this._isForceUnloaded, 'model (%s) permanently deleted', this.id);
    }
  }, {
    key: "isDeleted",
    get: function get() {
      if (this._isForceUnloaded) {
        return true;
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(AbstractModelWithAsyncData.prototype), "isDeleted", this);
    }
    /** */

  }, {
    key: "isDataLoaded",
    get: function get() {
      if (this.isDeleted) {
        return false;
      }

      return this._isDataLoaded;
    }
    /** @internal */

  }]);
  return AbstractModelWithAsyncData;
}(_abstract_model.default);

(0, _defineProperty2.default)(AbstractModelWithAsyncData, "__DATA_UNLOAD_DELAY_MS", 1000);
var _default = AbstractModelWithAsyncData;
exports.default = _default;