"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mutations = require("../types/mutations");

var _field = require("../types/field");

var _private_utils = require("../private_utils");

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

/** @module @airtable/blocks/models: Field */

/** */
// This doesn't follow our enum naming conventions because we want the keys
// to mirror the method/getter names on the model class.
var WatchableFieldKeys = Object.freeze({
  name: 'name',
  type: 'type',
  options: 'options',
  isComputed: 'isComputed',
  description: 'description'
});
/**
 * All the watchable keys in a field.
 * - `name`
 * - `type`
 * - `options`
 * - `isComputed`
 * - `description`
 */

/**
 * Model class representing a field in a table.
 *
 * @example
 * ```js
 * import {base} from '@airtable/blocks';
 *
 * const table = base.getTableByName('Table 1');
 * const field = table.getFieldByName('Name');
 * console.log('The type of this field is', field.type);
 * ```
 * @docsPath models/Field
 */
var Field =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(Field, _AbstractModel);
  (0, _createClass2.default)(Field, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableFieldKeys, key);
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function Field(sdk, parentTable, fieldId) {
    var _this;

    (0, _classCallCheck2.default)(this, Field);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Field).call(this, sdk, fieldId));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_parentTable", void 0);
    _this._parentTable = parentTable;
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(Field, [{
    key: "checkPermissionsForUpdateOptions",

    /**
     * Checks whether the current user has permission to perform the given options update.
     *
     * Accepts partial input, in the same format as {@link updateOptionsAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param options new options for the field
     *
     * @example
     * ```js
     * const updateFieldCheckResult = field.checkPermissionsForUpdateOptions();
     *
     * if (!updateFieldCheckResult.hasPermission) {
     *     alert(updateFieldCheckResult.reasonDisplayString);
     * }
     * ```
     */
    value: function checkPermissionsForUpdateOptions(options) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG,
        tableId: this.parentTable.id,
        id: this.id,
        config: {
          type: this.type,
          options: options
        }
      });
    }
    /**
     * An alias for `checkPermissionsForUpdateOptions(options).hasPermission`.
     *
     * Checks whether the current user has permission to perform the options update.
     *
     * Accepts partial input, in the same format as {@link updateOptionsAsync}.
     *
     * @param options new options for the field
     *
     * @example
     * ```js
     * const canUpdateField = field.hasPermissionToUpdateOptions();
     *
     * if (!canUpdateField) {
     *     alert('not allowed!');
     * }
     * ```
     */

  }, {
    key: "hasPermissionToUpdateOptions",
    value: function hasPermissionToUpdateOptions(options) {
      return this.checkPermissionsForUpdateOptions(options).hasPermission;
    }
    /**
     * Updates the options for this field.
     *
     * Throws an error if the user does not have permission to update the field, if invalid
     * options are provided, if this field has no writable options, or if updates to this field
     * type is not supported.
     *
     * Refer to {@link FieldType} for supported field types, the write format for options, and
     * other specifics for certain field types.
     *
     * This action is asynchronous. Unlike updates to cell values, updates to field options are
     * **not** applied optimistically locally. You must `await` the returned promise before
     * relying on the change in your app.
     *
     * Optionally, you can pass an `opts` object as the second argument. See {@link UpdateFieldOptionsOpts}
     * for available options.
     *
     * @param options new options for the field
     * @param opts optional options to affect the behavior of the update
     *
     * @example
     * ```js
     * async function addChoiceToSelectField(selectField, nameForNewOption) {
     *     const updatedOptions = {
     *         choices: [
     *             ...selectField.options.choices,
     *             {name: nameForNewOption},
     *         ]
     *     };
     *
     *     if (selectField.hasPermissionToUpdateOptions(updatedOptions)) {
     *         await selectField.updateOptionsAsync(updatedOptions);
     *     }
     * }
     * ```
     */

  }, {
    key: "updateOptionsAsync",
    value: function updateOptionsAsync(options) {
      var opts,
          _args = arguments;
      return _regenerator.default.async(function updateOptionsAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.next = 3;
              return _regenerator.default.awrap(this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG,
                tableId: this.parentTable.id,
                id: this.id,
                config: {
                  type: this.type,
                  options: options
                },
                opts
              }));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * `true` if this field is computed, `false` otherwise. A field is
     * "computed" if it's value is not set by user input (e.g. autoNumber, formula,
     * etc.). Can be watched
     *
     * @example
     * ```js
     * console.log(mySingleLineTextField.isComputed);
     * // => false
     * console.log(myAutoNumberField.isComputed);
     * // => true
     * ```
     */

  }, {
    key: "isAggregatorAvailable",
    // The following method is untested because its implementation resists
    // testing and because it is expected to be redesigned.
    // istanbul ignore next

    /**
     * Checks if the given aggregator is available for this field.
     *
     * @param aggregator The aggregator object or aggregator key.
     * @example
     * ```js
     * import {aggregators} from '@airtable/blocks/models';
     * const aggregator = aggregators.totalAttachmentSize;
     *
     * // Using an aggregator object
     * console.log(myAttachmentField.isAggregatorAvailable(aggregator));
     * // => true
     *
     * // Using an aggregator key
     * console.log(myTextField.isAggregatorAvailable('totalAttachmentSize'));
     * // => false
     * ```
     */
    value: function isAggregatorAvailable(aggregator) {
      var aggregatorKey = typeof aggregator === 'string' ? aggregator : aggregator.key;
      var airtableInterface = this._sdk.__airtableInterface;
      var availableAggregatorKeys = airtableInterface.aggregators.getAvailableAggregatorKeysForField(this._data);
      return availableAggregatorKeys.some(key => key === aggregatorKey);
    }
    /**
     * Attempt to parse a given string and return a valid cell value for the field's current config.
     * Returns `null` if unable to parse the given string.
     *
     * @param string The string to parse.
     * @example
     * ```js
     * const inputString = '42';
     * const cellValue = myNumberField.convertStringToCellValue(inputString);
     * console.log(cellValue === 42);
     * // => true
     * ```
     */

  }, {
    key: "convertStringToCellValue",
    value: function convertStringToCellValue(string) {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;
      var cellValue = airtableInterface.fieldTypeProvider.convertStringToCellValue(appInterface, string, this._data); // Temporarily bail out of validating computed values (since validation will crash)
      // while we work out if we actually have to validate or not. Ideally we just delete all
      // the validation
      // TODO(emma): delete me or tidy me up

      if (this.isComputed) {
        return cellValue;
      } // TODO(emma): do we need to validate here?


      var validationResult = airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, cellValue, null, this._data);

      if (validationResult.isValid) {
        return cellValue;
      } else {
        return null;
      }
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForDirtyPaths",
    value: function __triggerOnChangeForDirtyPaths(dirtyPaths) {
      if (dirtyPaths.name) {
        this._onChange(WatchableFieldKeys.name);
      }

      if (dirtyPaths.type) {
        this._onChange(WatchableFieldKeys.type); // TODO: it would be better if we only trigger this when
        // we know isComputed changed.


        this._onChange(WatchableFieldKeys.isComputed);
      }

      if (dirtyPaths.typeOptions) {
        this._onChange(WatchableFieldKeys.options);
      }

      if (dirtyPaths.description) {
        this._onChange(WatchableFieldKeys.description);
      }
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _ref;

      var tableData = this._baseData.tablesById[this.parentTable.id];
      return (_ref = tableData === null || tableData === void 0 ? void 0 : tableData.fieldsById[this._id]) !== null && _ref !== void 0 ? _ref : null;
    }
    /**
     * The table that this field belongs to. Should never change because fields aren't moved between tables.
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * @example
     * ```js
     * const field = myTable.getFieldByName('Name');
     * console.log(field.parentTable.id === myTable.id);
     * // => true
     * ```
     */

  }, {
    key: "parentTable",
    get: function get() {
      return this._parentTable;
    }
    /**
     * The name of the field. Can be watched.
     *
     * @example
     * ```js
     * console.log(myField.name);
     * // => 'Name'
     * ```
     */

  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
    /**
     * The type of the field. Can be watched.
     *
     * @example
     * ```js
     * console.log(myField.type);
     * // => 'singleLineText'
     * ```
     */

  }, {
    key: "type",
    get: function get() {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;

      var _airtableInterface$fi = airtableInterface.fieldTypeProvider.getConfig(appInterface, this._data, this.parentTable.__getFieldNamesById()),
          type = _airtableInterface$fi.type; // We intend to switch from "lookup" to "multipleLookupValues", but need to support both
      // until the transition is complete. See <https://airtable.quip.com/VxaMAmAfUscs> for more.
      // @ts-ignore


      if (type === 'lookup') {
        return _field.FieldType.MULTIPLE_LOOKUP_VALUES;
      } else {
        return type;
      }
    }
    /**
     * The configuration options of the field. The structure of the field's
     * options depend on the field's type. `null` if the field has no options.
     * Can be watched.
     *
     * @see {@link FieldType}
     * @example
     * ```js
     * import {FieldType} from '@airtable/blocks/models';
     *
     * if (myField.type === FieldType.CURRENCY) {
     *     console.log(myField.options.symbol);
     *     // => '$'
     * }
     * ```
     */

  }, {
    key: "options",
    get: function get() {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;

      var _airtableInterface$fi2 = airtableInterface.fieldTypeProvider.getConfig(appInterface, this._data, this.parentTable.__getFieldNamesById()),
          options = _airtableInterface$fi2.options; // TODO(emma): can we remove this cloneDeep?


      return options ? (0, _private_utils.cloneDeep)(options) : null;
    }
    /**
     * The type and options of the field to make type narrowing `FieldOptions` easier.
     *
     * @see {@link FieldConfig}
     * @example
     * const fieldConfig = field.config;
     * if (fieldConfig.type === FieldType.SINGLE_SELECT) {
     *     return fieldConfig.options.choices;
     * } else if (fieldConfig.type === FieldType.MULTIPLE_LOOKUP_VALUES && fieldConfig.options.isValid) {
     *     if (fieldConfig.options.result.type === FieldType.SINGLE_SELECT) {
     *         return fieldConfig.options.result.options.choices;
     *     }
     * }
     * return DEFAULT_CHOICES;
     */

  }, {
    key: "config",
    get: function get() {
      return {
        type: this.type,
        options: this.options
      };
    }
  }, {
    key: "isComputed",
    get: function get() {
      var airtableInterface = this._sdk.__airtableInterface;
      return airtableInterface.fieldTypeProvider.isComputed(this._data);
    }
    /**
     * `true` if this field is its parent table's primary field, `false` otherwise.
     * Should never change because the primary field of a table cannot change.
     */

  }, {
    key: "isPrimaryField",
    get: function get() {
      return this.id === this.parentTable.primaryField.id;
    }
    /**
     * The description of the field, if it has one. Can be watched.
     *
     * @example
     * ```js
     * console.log(myField.description);
     * // => 'This is my field'
     * ```
     */

  }, {
    key: "description",
    get: function get() {
      return this._data.description;
    } // The following method is untested because its implementation resists
    // testing and because it is expected to be redesigned.
    // istanbul ignore next

    /**
     * A list of available aggregators given this field's configuration.
     *
     * @example
     * ```js
     * const fieldAggregators = myField.availableAggregators;
     * ```
     */

  }, {
    key: "availableAggregators",
    get: function get() {
      var airtableInterface = this._sdk.__airtableInterface;
      var availableAggregatorKeysSet = new Set(airtableInterface.aggregators.getAvailableAggregatorKeysForField(this._data));

      var _require = require('./models'),
          aggregators = _require.aggregators;

      return (0, _private_utils.values)(aggregators).filter(aggregator => {
        return availableAggregatorKeysSet.has(aggregator.key);
      });
    }
  }]);
  return Field;
}(_abstract_model.default);

(0, _defineProperty2.default)(Field, "_className", 'Field');
var _default = Field;
exports.default = _default;