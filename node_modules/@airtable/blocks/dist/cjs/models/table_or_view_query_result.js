"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _table = _interopRequireWildcard(require("./table"));

var _record_query_result = _interopRequireDefault(require("./record_query_result"));

var _record_coloring = require("./record_coloring");

var _object_pool = _interopRequireDefault(require("./object_pool"));

var _record_store = require("./record_store");

var _view_data_store = _interopRequireWildcard(require("./view_data_store"));

var _grouped_record_query_result = _interopRequireDefault(require("./grouped_record_query_result"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Represents a set of records directly from a view or table. See {@link RecordQueryResult} for main
 * documentation.
 *
 * Do not instantiate. You can get instances of this class by calling
 * `table.selectRecords` or `view.selectRecords`.
 *
 * @docsPath models/query results/TableOrViewQueryResult
 */
var TableOrViewQueryResult =
/*#__PURE__*/
function (_RecordQueryResult) {
  (0, _inherits2.default)(TableOrViewQueryResult, _RecordQueryResult);

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */
  // If custom sorts or groups are specified, we'll use a VisList to handle sorting.
  // If no sorts are specified, we'll use the underlying row order of the source model.
  // Note: we're currently handling visibility tracking for view query results within this class,
  // not in the VisList. In other words, only visible records are added to the visList.

  /** @internal */

  /** @internal */
  // These is the groupLevels provided to us by the user when executing a query

  /** @internal */
  // This is the ordered list of record ids.

  /** @internal */
  // This is the ordered list of groups.

  /** @internal */
  // An ordered list of group levels returned to us from hyperbase, this should not be
  // read from directly, but instead via this.data.groupLevels (Writing to this on hyperbase updates).
  // (which check's that this model has not been not deleted)

  /** @internal */
  // lazily generated set of record ids

  /** @internal */
  // NOTE: when a cellValue key (cellValues or cellValuesInField:) is watched, we want
  // to make sure we watch the associated key on the table. However, we need to make
  // sure that we only watch the table once for each key. Otherwise, the callbacks
  // for each key will get called more than once for each change event. This is because
  // Watchable stores references to callbacks for each key, and on each _onChange event
  // calls each callback for that key. If we watch the table more than once, then we'll
  // call _onChange more than once, and each callback will be called more than once, which
  // is undesirable. Instead, we'll store watch counts for each key to make sure we only
  // watch the table once.

  /** @internal */

  /** @internal */

  /** @internal */
  function TableOrViewQueryResult(sdk, sourceModel, normalizedOpts) {
    var _this;

    (0, _classCallCheck2.default)(this, TableOrViewQueryResult);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TableOrViewQueryResult).call(this, sdk, normalizedOpts));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_sourceModel", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_mostRecentSourceModelLoadPromise", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_table", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_fieldIdsSetToLoadOrNullIfAllFields", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_visList", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_sorts", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_groupLevels", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_orderedRecordIds", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_orderedGroups", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_loadedGroupLevels", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_recordIdsSet", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_cellValueKeyWatchCounts", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "__groupedRecordQueryResultPool", void 0);
    _this._sourceModel = sourceModel;
    _this._mostRecentSourceModelLoadPromise = null;
    _this._table = normalizedOpts.table;
    var sorts = _this._normalizedOpts.sorts;
    _this._sorts = sorts !== null && sorts !== void 0 ? sorts : null; // TODO (SeanKeenan): Placeholder until we support groups from normalizedOpts

    _this._groupLevels = null;
    _this._visList = null;
    _this._orderedRecordIds = null;
    _this._orderedGroups = null;
    _this._loadedGroupLevels = null;
    _this._cellValueKeyWatchCounts = {};
    var fieldIdsSetToLoadOrNullIfAllFields = null;

    if (_this._normalizedOpts.fieldIdsOrNullIfAllFields) {
      fieldIdsSetToLoadOrNullIfAllFields = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _this._normalizedOpts.fieldIdsOrNullIfAllFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fieldId = _step.value;
          fieldIdsSetToLoadOrNullIfAllFields[fieldId] = true;
        } // Need to load data for fields we're sorting by, even if
        // they're not explicitly requested in the `fields` opt.

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (_this._sorts !== null) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _this._sorts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var sort = _step2.value;
            fieldIdsSetToLoadOrNullIfAllFields[sort.fieldId] = true;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } // TODO (SeanKeenan): Comment back in when enabling groups
      // Same for group configs
      // if (this._groupLevels !== null) {
      //     for (const group of this._groupLevels) {
      //         fieldIdsSetToLoadOrNullIfAllFields[group.fieldId] = true;
      //     }
      // }


      var recordColorMode = _this._normalizedOpts.recordColorMode;

      if (recordColorMode && recordColorMode.type === _record_coloring.ModeTypes.BY_SELECT_FIELD) {
        fieldIdsSetToLoadOrNullIfAllFields[recordColorMode.selectField.id] = true;
      }
    }

    _this._fieldIdsSetToLoadOrNullIfAllFields = fieldIdsSetToLoadOrNullIfAllFields;
    _this.__groupedRecordQueryResultPool = new _object_pool.default(_grouped_record_query_result.default);
    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  /** @internal */


  (0, _createClass2.default)(TableOrViewQueryResult, [{
    key: "_getOrGenerateRecordIdsSet",

    /**
     * The set of record IDs in this RecordQueryResult.
     * Throws if data is not loaded yet.
     *
     * @internal
     */
    value: function _getOrGenerateRecordIdsSet() {
      if (!this._recordIdsSet) {
        var recordIdsSet = {};
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.recordIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var recordId = _step3.value;
            recordIdsSet[recordId] = true;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        this._recordIdsSet = recordIdsSet;
      }

      return this._recordIdsSet;
    }
    /**
     * The fields that were used to create this RecordQueryResult.
     * Null if fields were not specified, which means the RecordQueryResult
     * will load all fields in the table.
     */

  }, {
    key: "_incrementCellValueKeyWatchCountAndWatchIfNecessary",

    /** @internal */
    value: function _incrementCellValueKeyWatchCountAndWatchIfNecessary(key, watchCallback) {
      if (!this._cellValueKeyWatchCounts[key]) {
        this._cellValueKeyWatchCounts[key] = 0;

        this._recordStore.watch(key, watchCallback, this);
      }

      this._cellValueKeyWatchCounts[key]++;
    }
    /** @internal */

  }, {
    key: "_decrementCellValueKeyWatchCountAndUnwatchIfPossible",
    value: function _decrementCellValueKeyWatchCountAndUnwatchIfPossible(key, watchCallback) {
      if (!this._cellValueKeyWatchCounts[key]) {
        // Key isn't watched, so just skip it. This matches behavior of Watchable,
        // where calling unwatch on a key that isn't watched just no-ops.
        return;
      }

      this._cellValueKeyWatchCounts[key]--;

      if (this._cellValueKeyWatchCounts[key] === 0) {
        // We're down to zero watches for this key, so we can actually unwatch it now.
        this._recordStore.unwatch(key, watchCallback, this);

        delete this._cellValueKeyWatchCounts[key];
      }
    }
    /** @inheritdoc */

  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "watch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = validKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _key2 = _step4.value;

          if (_key2.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = _key2.substring(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);

            if (this._fieldIdsSetToLoadOrNullIfAllFields && !(0, _private_utils.has)(this._fieldIdsSetToLoadOrNullIfAllFields, fieldId)) {
              throw (0, _error_utils.spawnError)("Can't watch field because it wasn't included in RecordQueryResult fields: %s", fieldId);
            }

            this._incrementCellValueKeyWatchCountAndWatchIfNecessary(_key2, this._onCellValuesInFieldChanged);
          }

          if (_key2 === _record_query_result.default.WatchableKeys.cellValues) {
            if (this._fieldIdsSetToLoadOrNullIfAllFields) {
              for (var _i = 0, _Object$keys = Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields); _i < _Object$keys.length; _i++) {
                var _fieldId = _Object$keys[_i];

                this._incrementCellValueKeyWatchCountAndWatchIfNecessary(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + _fieldId, this._onCellValuesChanged);
              }
            } else {
              this._incrementCellValueKeyWatchCountAndWatchIfNecessary(_key2, this._onCellValuesChanged);
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return validKeys;
    }
    /** @inheritdoc */

  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "unwatch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = validKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _key3 = _step5.value;

          if (_key3.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            this._decrementCellValueKeyWatchCountAndUnwatchIfPossible(_key3, this._onCellValuesInFieldChanged);
          }

          if (_key3 === _record_query_result.default.WatchableKeys.cellValues) {
            if (this._fieldIdsSetToLoadOrNullIfAllFields) {
              for (var _i2 = 0, _Object$keys2 = Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields); _i2 < _Object$keys2.length; _i2++) {
                var fieldId = _Object$keys2[_i2];

                this._decrementCellValueKeyWatchCountAndUnwatchIfPossible(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, this._onCellValuesChanged);
              }
            } else {
              this._decrementCellValueKeyWatchCountAndUnwatchIfPossible(_key3, this._onCellValuesChanged);
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return validKeys;
    }
    /** @inheritdoc */

  }, {
    key: "loadDataAsync",
    value: function loadDataAsync() {
      var sourceModelLoadPromise, cellValuesInFieldsLoadPromise;
      return _regenerator.default.async(function loadDataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this._sourceModel.isDeleted) {
                _context.next = 2;
                break;
              }

              throw this._spawnErrorForDeletion();

            case 2:
              if (this._fieldIdsSetToLoadOrNullIfAllFields) {
                cellValuesInFieldsLoadPromise = this._recordStore.loadCellValuesInFieldIdsAsync(Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields));
              } else {
                // Load all fields.
                cellValuesInFieldsLoadPromise = this._recordStore.loadDataAsync();
              }

              if (this._sourceModel instanceof _table.default) {
                if (this._fieldIdsSetToLoadOrNullIfAllFields) {
                  sourceModelLoadPromise = this._recordStore.loadRecordMetadataAsync();
                } else {
                  // table.loadDataAsync is a superset of loadRecordMetadataAsync,
                  // so no need to load record metadata again.
                  sourceModelLoadPromise = null;
                }
              } else {
                sourceModelLoadPromise = this._recordStore.getViewDataStore(this._sourceModel.id).loadDataAsync();
              }

              this._mostRecentSourceModelLoadPromise = Promise.all([sourceModelLoadPromise, cellValuesInFieldsLoadPromise, this._loadRecordColorsAsync()]);
              _context.next = 7;
              return _regenerator.default.awrap((0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "loadDataAsync", this).call(this));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * @internal
     */

  }, {
    key: "_getChangedKeysOnLoad",
    value: function _getChangedKeysOnLoad() {
      var changedKeys = [_record_query_result.default.WatchableKeys.records, _record_query_result.default.WatchableKeys.recordIds, _record_query_result.default.WatchableKeys.cellValues, _record_query_result.default.WatchableKeys.groups, _record_query_result.default.WatchableKeys.groupLevels];

      var fieldIds = this._normalizedOpts.fieldIdsOrNullIfAllFields || this._table.fields.map(field => field.id);

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = fieldIds[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var fieldId = _step6.value;
          changedKeys.push(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return changedKeys;
    }
    /** @internal */

  }, {
    key: "_loadDataAsync",
    value: function _loadDataAsync() {
      var viewDataStore, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, sort, field;

      return _regenerator.default.async(function _loadDataAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this._table.__tableOrViewQueryResultPool.registerObjectForReuseStrong(this);

              (0, _error_utils.invariant)(this._mostRecentSourceModelLoadPromise, 'No source model load promises');
              _context2.next = 4;
              return _regenerator.default.awrap(this._mostRecentSourceModelLoadPromise);

            case 4:
              if (this._sorts) {
                this._replaceVisList();
              }

              this._orderedRecordIds = this._generateOrderedRecordIds();
              this._orderedGroups = this._generateAndLoadOrderedGroups(); // The server provided value and developer supplied value are the same, no conversion needed

              this._loadedGroupLevels = this._sourceModelGroupLevels;

              if (this._sourceModel instanceof _table.default) {
                this._recordStore.watch(_record_store.WatchableRecordStoreKeys.records, this._onRecordsChanged, this);
              } else {
                viewDataStore = this._recordStore.getViewDataStore(this._sourceModel.id);
                viewDataStore.watch(_view_data_store.WatchableViewDataStoreKeys.visibleRecords, this._onRecordsChanged, this);
                viewDataStore.watch(_view_data_store.WatchableViewDataStoreKeys.groups, this._onGroupsChanged, this);
                viewDataStore.watch(_view_data_store.WatchableViewDataStoreKeys.groupLevels, this._onGroupLevelsChanged, this);
              }

              this._recordStore.watch(this._cellValuesForSortWatchKeys, this._onCellValuesForSortChanged, this);

              this._recordStore.watch(this._cellValuesForGroupWatchKeys, this._onCellValuesForGroupChanged, this);

              this._table.watch(_table.WatchableTableKeys.fields, this._onTableFieldsChanged, this);

              if (!this._sorts) {
                _context2.next = 32;
                break;
              }

              _iteratorNormalCompletion7 = true;
              _didIteratorError7 = false;
              _iteratorError7 = undefined;
              _context2.prev = 16;

              for (_iterator7 = this._sorts[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                sort = _step7.value;
                field = this._table.getFieldByIdIfExists(sort.fieldId);

                if (field) {
                  field.watch('type', this._onFieldConfigChanged, this);
                  field.watch('options', this._onFieldConfigChanged, this);
                }
              }

              _context2.next = 24;
              break;

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](16);
              _didIteratorError7 = true;
              _iteratorError7 = _context2.t0;

            case 24:
              _context2.prev = 24;
              _context2.prev = 25;

              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }

            case 27:
              _context2.prev = 27;

              if (!_didIteratorError7) {
                _context2.next = 30;
                break;
              }

              throw _iteratorError7;

            case 30:
              return _context2.finish(27);

            case 31:
              return _context2.finish(24);

            case 32:
              return _context2.abrupt("return", this._getChangedKeysOnLoad());

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[16, 20, 24, 32], [25,, 27, 31]]);
    }
    /** @inheritdoc */

  }, {
    key: "unloadData",
    value: function unloadData() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "unloadData", this).call(this);

      if (this._sourceModel instanceof _table.default) {
        if (this._fieldIdsSetToLoadOrNullIfAllFields) {
          this._recordStore.unloadRecordMetadata();
        } else {
          this._recordStore.unloadData();
        }
      } else {
        // If the view is deleted, we can't get a data store for it.
        if (!this._sourceModel.isDeleted) {
          this._recordStore.getViewDataStore(this._sourceModel.id).unloadData();
        }
      }

      if (this._fieldIdsSetToLoadOrNullIfAllFields) {
        this._recordStore.unloadCellValuesInFieldIds(Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields));
      }

      this._unloadRecordColors();
    }
    /** @internal */

  }, {
    key: "_unloadData",
    value: function _unloadData() {
      this._mostRecentSourceModelLoadPromise = null;

      if (this._sourceModel instanceof _table.default) {
        this._recordStore.unwatch(_record_store.WatchableRecordStoreKeys.records, this._onRecordsChanged, this);
      } else {
        if (!this._sourceModel.isDeleted) {
          var viewDataStore = this._recordStore.getViewDataStore(this._sourceModel.id);

          viewDataStore.unwatch(_view_data_store.WatchableViewDataStoreKeys.visibleRecords, this._onRecordsChanged, this);
          viewDataStore.unwatch(_view_data_store.WatchableViewDataStoreKeys.groups, this._onGroupsChanged, this);
          viewDataStore.unwatch(_view_data_store.WatchableViewDataStoreKeys.groupLevels, this._onGroupLevelsChanged, this);
        }
      }

      this._recordStore.unwatch(this._cellValuesForSortWatchKeys, this._onCellValuesForSortChanged, this);

      this._recordStore.unwatch(this._cellValuesForGroupWatchKeys, this._onCellValuesForGroupChanged, this);

      this._table.unwatch(_table.WatchableTableKeys.fields, this._onTableFieldsChanged, this); // If the table is deleted, can't call getFieldById on it below.


      if (!this._table.isDeleted && this._sorts) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = this._sorts[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var sort = _step8.value;

            var field = this._table.getFieldByIdIfExists(sort.fieldId);

            if (field) {
              field.unwatch('type', this._onFieldConfigChanged, this);
              field.unwatch('options', this._onFieldConfigChanged, this);
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }

      this._unloadOrderedGroupsIfNeeded();

      this._visList = null;
      this._orderedRecordIds = null;
      this._recordIdsSet = null;

      this._table.__tableOrViewQueryResultPool.unregisterObjectForReuseStrong(this);
    }
    /** @internal */

  }, {
    key: "_addRecordIdsToVisList",
    value: function _addRecordIdsToVisList(recordIds) {
      var visList = this._visList;
      (0, _error_utils.invariant)(visList, 'No vis list');
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = recordIds[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var recordId = _step9.value;

          var record = this._recordStore.getRecordByIdIfExists(recordId);

          (0, _error_utils.invariant)(record, 'Record missing in table');
          visList.addRecordData(record._data);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
    /** @internal */

  }, {
    key: "_onGroupLevelsChanged",
    value: function _onGroupLevelsChanged(model, key, updates) {
      this._loadedGroupLevels = this._sourceModelGroupLevels;

      this._unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches();

      this._onChange(_record_query_result.default.WatchableKeys.groupLevels);
    }
    /** @internal */

  }, {
    key: "_onGroupsChanged",
    value: function _onGroupsChanged(model, key, updates) {
      this._unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches();
    }
    /** @internal */

  }, {
    key: "_onRecordsChanged",
    value: function _onRecordsChanged(model, key, updates) {
      if (model instanceof _view_data_store.default) {
        // For a view model, we don't get updates sent with the onChange event,
        // so we need to manually generate updates based on the old and new
        // recordIds.
        (0, _error_utils.invariant)(this._orderedRecordIds, '_orderedRecordIds unset');

        var visibleRecordIds = this._recordStore.getViewDataStore(model.viewId).visibleRecordIds;

        var _addedRecordIds = (0, _private_utils.arrayDifference)(visibleRecordIds, this._orderedRecordIds);

        var _removedRecordIds = (0, _private_utils.arrayDifference)(this._orderedRecordIds, visibleRecordIds);

        updates = {
          addedRecordIds: _addedRecordIds,
          removedRecordIds: _removedRecordIds
        };
      }

      if (!updates) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a records change twice with no data).
        return;
      }

      var _updates = updates,
          addedRecordIds = _updates.addedRecordIds,
          removedRecordIds = _updates.removedRecordIds;

      if (this._sorts) {
        var visList = this._visList;
        (0, _error_utils.invariant)(visList, 'No vis list');

        if (removedRecordIds.length > 0) {
          visList.removeRecordIds(removedRecordIds);
        }

        if (addedRecordIds.length > 0) {
          this._addRecordIdsToVisList(addedRecordIds);
        }
      }

      if (this._recordIdsSet) {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = addedRecordIds[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var recordId = _step10.value;
            this._recordIdsSet[recordId] = true;
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }

        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = removedRecordIds[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var _recordId = _step11.value;
            this._recordIdsSet[_recordId] = undefined;
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      } // Now that we've applied our changes (if applicable), let's regenerate our recordIds.


      this._orderedRecordIds = this._generateOrderedRecordIds();

      this._onChange(_record_query_result.default.WatchableKeys.records, updates);

      this._onChange(_record_query_result.default.WatchableKeys.recordIds, updates);
    }
    /** @internal */
    // istanbul ignore next

  }, {
    key: "_onCellValuesForGroupChanged",
    value: function _onCellValuesForGroupChanged(recordStore, key, recordIds, fieldId) {} // TODO(SeanKeenan): This isn't yet required as we don't yet support
    // specifying groups for a custom query, and this will only be called
    // if we specify groups (same as _onCellValuesForSortChanged)
    // This functionality and _onCellValuesForSortChanged should be
    // identical, but testing, validation, and careful thought is required.

    /** @internal */

  }, {
    key: "_onCellValuesForSortChanged",
    value: function _onCellValuesForSortChanged(recordStore, key, recordIds, fieldId) {
      if (!recordIds || !fieldId) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a records change twice with no data).
        return;
      } // NOTE: this will only ever be called if we have sorts, so it's safe to assert that we have
      // a vis list here.


      var visList = this._visList;
      (0, _error_utils.invariant)(visList, 'No vis list');
      (0, _error_utils.invariant)(recordIds.length > 0, 'field ID set without a corresponding record ID'); // Only move recordIds that are already in the visList.
      // It's possible to have recordId that is not currently in the visList since
      // this callback can run before onRecordsChanged. (eg. when a deleted record is
      // restored, this is triggered for that record but the record is not yet in the visList:
      // onRecordsChanged actually adds it)
      // Note: cell value changes that result in the records being filtered out trigger
      //       onRecordsChanged on the View model, so we don't have to worry about that here.

      var visListRecordIdsSet = new Set(visList.getOrderedRecordIds());
      var recordIdsToMove = recordIds.filter(recordId => visListRecordIdsSet.has(recordId));
      visList.removeRecordIds(recordIdsToMove);

      this._addRecordIdsToVisList(recordIdsToMove);

      this._orderedRecordIds = this._generateOrderedRecordIds();
      var changeData = {
        addedRecordIds: [],
        removedRecordIds: []
      };

      this._onChange(_record_query_result.default.WatchableKeys.records, changeData);

      this._onChange(_record_query_result.default.WatchableKeys.recordIds, changeData);
    }
    /** @internal */

  }, {
    key: "_onFieldConfigChanged",
    value: function _onFieldConfigChanged(_field, _key) {
      // Field config changed for a field we rely on, so we need to replace our vis list.
      // NOTE: this will only ever be called if we have sorts, so it's safe to assume we
      // are using a vis list here.
      this._replaceVisList();

      this._orderedRecordIds = this._generateOrderedRecordIds();
    }
    /** @internal */

  }, {
    key: "_onTableFieldsChanged",
    value: function _onTableFieldsChanged(table, key, updates) {
      if (!this._sorts) {
        // If we don't have any sorts, we don't have to do anything in response to field changes.
        return;
      }

      var addedFieldIds = updates.addedFieldIds,
          removedFieldIds = updates.removedFieldIds;
      var fieldIdsSet = new Set(this._sorts.map(sort => sort.fieldId)); // Check if any fields that we rely on were created or deleted. If they were,
      // replace our vis list.
      // NOTE: we need to check for created, since a field that we rely on can be
      // deleted and then undeleted.

      var wereAnyFieldsCreatedOrDeleted = false;
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = addedFieldIds[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var fieldId = _step12.value;

          // If a field that we rely on was created (i.e. it was undeleted), we need to
          // make sure we're watching it's config.
          if (fieldIdsSet.has(fieldId)) {
            wereAnyFieldsCreatedOrDeleted = true;

            var field = this._table.getFieldByIdIfExists(fieldId);

            (0, _error_utils.invariant)(field, 'Created field does not exist');
            field.watch('type', this._onFieldConfigChanged, this);
            field.watch('options', this._onFieldConfigChanged, this);
          }
        } // coverage analysis
        // istanbul ignore else

      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      if (!wereAnyFieldsCreatedOrDeleted) {
        wereAnyFieldsCreatedOrDeleted = removedFieldIds.some(fieldId => fieldIdsSet.has(fieldId));
      }

      if (wereAnyFieldsCreatedOrDeleted) {
        // One of the fields we're relying on was deleted,
        this._replaceVisList();

        this._orderedRecordIds = this._generateOrderedRecordIds(); // Make sure we fire onChange events since the order may have changed
        // as a result.

        var changeData = {
          addedRecordIds: [],
          removedRecordIds: []
        };

        this._onChange(_record_query_result.default.WatchableKeys.records, changeData);

        this._onChange(_record_query_result.default.WatchableKeys.recordIds, changeData); // We do not unload/reload groupQueryResults if it's field is deleted as
        // it is responsible for failing to load if the field doesn't exist

      }
    }
    /** @internal */

  }, {
    key: "_onCellValuesChanged",
    value: function _onCellValuesChanged(table, key, updates) {
      if (!updates) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a cellValues change twice with no data).
        return;
      }

      this._onChange(_record_query_result.default.WatchableKeys.cellValues, updates);
    }
    /** @internal */

  }, {
    key: "_onCellValuesInFieldChanged",
    value: function _onCellValuesInFieldChanged(table, key, recordIds, fieldId) {
      if (!recordIds && !fieldId) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a cellValuesInField change twice with no data).
        return;
      }

      this._onChange(key, recordIds, fieldId);
    }
    /** @internal */

  }, {
    key: "_generateOrderedRecordIds",
    value: function _generateOrderedRecordIds() {
      if (this._sorts) {
        (0, _error_utils.invariant)(this._visList, 'Cannot generate record ids without a vis list');
        return this._visList.getOrderedRecordIds();
      } else {
        return this._sourceModelRecordIds;
      }
    }
    /** @internal */

  }, {
    key: "_generateAndLoadOrderedGroups",
    value: function _generateAndLoadOrderedGroups() {
      // istanbul ignore next
      if (this._groupLevels) {
        (0, _error_utils.invariant)(this._visList, 'Cannot generate record ids without a vis list');
        throw (0, _error_utils.spawnError)('custom group configs not supported');
      } else {
        // Get the group from the view itself
        var groupLevels = this._sourceModelGroupLevels;

        if (!this._sourceModelGroups || !groupLevels) {
          return null;
        }

        return this._sourceModelGroups.map(groupData => {
          var group = this.__groupedRecordQueryResultPool.getObjectForReuse(this, groupData, groupLevels, this._normalizedOpts, this._sdk); // Don't await the loading, let others check isDataLoaded.
          // (it doesn't take any time anyway). Loading also strong retains.


          group.loadDataAsync();
          return group;
        });
      }
    }
    /** @internal */

  }, {
    key: "_unloadOrderedGroupsIfNeeded",
    value: function _unloadOrderedGroupsIfNeeded() {
      if (this._orderedGroups) {
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = this._orderedGroups[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var group = _step13.value;
            group.unloadData();
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
              _iterator13.return();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }
      }
    }
    /**
     * If groupings change then some groups will need to be created, and some removed
     * This (TODO: will) handle the diffing necessary to unload, and reload only the changed groups.
     * Also triggers the WatchableKeys.group, as by necessity this will have changed.
     *
     * @internal
     */
    // TODO: (SeanKeenan) Properly diff and only unload groups that need to be unloaded
    // In the meantime it's not too expensive to just unload everything, and GroupedRecordQueryResults
    // don't yet properly watch changes relevant to updating, so this isn't too bad.
    // (They do invalidate their recordId caches, which is some very cheap work that we could remove)

  }, {
    key: "_unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches",
    value: function _unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches() {
      this._unloadOrderedGroupsIfNeeded();

      this._orderedGroups = this._generateAndLoadOrderedGroups();

      this._onChange(_record_query_result.default.WatchableKeys.groups);
    }
    /** @internal */

  }, {
    key: "_replaceVisList",
    value: function _replaceVisList() {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;

      var recordDatas = this._sourceModelRecords.map(record => record._data);

      var fieldDatas = this._table.fields.map(field => field._data);

      var filteredSorts = this._getSortsWithDeletedFieldsFiltered();

      this._visList = airtableInterface.createVisList(appInterface, recordDatas, fieldDatas, filteredSorts);
    }
    /** @internal */

  }, {
    key: "_getSortsWithDeletedFieldsFiltered",
    value: function _getSortsWithDeletedFieldsFiltered() {
      (0, _error_utils.invariant)(this._sorts, 'No sorts'); // Filter out any sorts levels that rely on deleted fields.
      // NOTE: we keep deleted fields around (rather than filtering them out
      // in realtime) in case a field gets undeleted, in which case we want to
      // keep using it.

      return this._sorts.filter(sort => {
        var field = this._table.getFieldByIdIfExists(sort.fieldId);

        return !!field;
      });
    }
    /** @internal */

  }, {
    key: "_spawnErrorForDeletion",
    value: function _spawnErrorForDeletion() {
      var sourceModelName = this._sourceModel instanceof _table.default ? 'table' : 'view';
      return (0, _error_utils.spawnError)("RecordQueryResult's underlying %s has been deleted", sourceModelName);
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      if (this._sourceModel.isDeleted || this._recordStore.isDeleted) {
        return null;
      }

      return {
        recordIds: this._orderedRecordIds,
        groups: this._orderedGroups,
        groupLevels: this._loadedGroupLevels
      };
    }
    /** @internal */
    // istanbul ignore next

  }, {
    key: "__sourceModelId",
    get: function get() {
      return this._sourceModel.id;
    }
    /** @internal */

  }, {
    key: "__poolKey",
    get: function get() {
      return "".concat(this._serializedOpts, "::").concat(this._sourceModel.id);
    }
    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The table that records in this RecordQueryResult are part of
     */

  }, {
    key: "parentTable",
    get: function get() {
      return this._table;
    }
    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The view that was used to obtain this RecordQueryResult by calling
     * `view.selectRecords`. Null if the RecordQueryResult was obtained by calling
     * `table.selectRecords`.
     */

  }, {
    key: "parentView",
    get: function get() {
      return this._sourceModel instanceof _table.default ? null : this._sourceModel;
    }
    /**
     * The record IDs in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     */

  }, {
    key: "recordIds",
    get: function get() {
      // The following statements have been carefully sequenced to ensure
      // that when this method fails, it reports the most salient error.
      var recordIds = this._data.recordIds; // Throws when the model has been deleted.

      (0, _error_utils.invariant)(this.isDataLoaded, 'RecordQueryResult data is not loaded');
      (0, _error_utils.invariant)(recordIds, 'No recordIds');
      return recordIds;
    }
    /**
     * The ordered GroupedRecordQueryResult's in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     *
     * @hidden
     */

  }, {
    key: "groups",
    get: function get() {
      // The following statements have been carefully sequenced to ensure
      // that when this method fails, it reports the most salient error.
      var groups = this._data.groups; // Throws when the model has been deleted.

      (0, _error_utils.invariant)(this.isDataLoaded, 'RecordQueryResult data is not loaded');
      return groups !== null && groups !== void 0 ? groups : null;
    }
    /**
     * The GroupLevels in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     *
     * @hidden
     */

  }, {
    key: "groupLevels",
    get: function get() {
      var groupLevels = this._data.groupLevels; // Throws when the model has been deleted.

      (0, _error_utils.invariant)(this.isDataLoaded, 'RecordQueryResult data is not loaded');
      return groupLevels ? groupLevels.map(singleLevel => _objectSpread({}, singleLevel, {
        field: this.parentTable.getFieldById(singleLevel.fieldId)
      })) : null;
    }
  }, {
    key: "fields",
    get: function get() {
      var fieldIdsOrNullIfAllFields = this._normalizedOpts.fieldIdsOrNullIfAllFields;

      if (fieldIdsOrNullIfAllFields) {
        var fields = []; // Filter out any deleted fields, since RecordQueryResult is "live".
        // It would be too cumbersome (and defeat part of the purpose of
        // using RecordQueryResult) if the user had to manually watch for deletion
        // on all the fields and recreate the RecordQueryResult.

        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = fieldIdsOrNullIfAllFields[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var fieldId = _step14.value;

            var field = this._table.getFieldByIdIfExists(fieldId);

            if (field !== null) {
              fields.push(field);
            }
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
              _iterator14.return();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }

        return fields;
      } else {
        return null;
      }
    }
    /** @internal */

  }, {
    key: "_cellValuesForSortWatchKeys",
    get: function get() {
      return this._sorts ? this._sorts.map(sort => "cellValuesInField:".concat(sort.fieldId)) : [];
    }
    /** @internal */

  }, {
    key: "_cellValuesForGroupWatchKeys",
    get: function get() {
      // _groupLevels can not be specified by the user during the query yet
      // istanbul ignore next
      return this._groupLevels ? this._groupLevels.map(group => "cellValuesInField:".concat(group.fieldId)) : [];
    }
    /** @internal */

  }, {
    key: "_sourceModelRecordIds",
    get: function get() {
      return this._sourceModel instanceof _table.default ? this._recordStore.recordIds : this._recordStore.getViewDataStore(this._sourceModel.id).visibleRecordIds;
    }
    /** @internal */

  }, {
    key: "_sourceModelGroups",
    get: function get() {
      return this._sourceModel instanceof _table.default ? null : this._recordStore.getViewDataStore(this._sourceModel.id).groups;
    }
    /** @internal */

  }, {
    key: "_sourceModelGroupLevels",
    get: function get() {
      return this._sourceModel instanceof _table.default ? null : this._recordStore.getViewDataStore(this._sourceModel.id).groupLevels;
    }
    /** @internal */

  }, {
    key: "_sourceModelRecords",
    get: function get() {
      return this._sourceModel instanceof _table.default ? this._recordStore.records : this._recordStore.getViewDataStore(this._sourceModel.id).visibleRecords;
    }
  }]);
  return TableOrViewQueryResult;
}(_record_query_result.default);

(0, _defineProperty2.default)(TableOrViewQueryResult, "_className", 'TableOrViewQueryResult');
var _default = TableOrViewQueryResult;
exports.default = _default;