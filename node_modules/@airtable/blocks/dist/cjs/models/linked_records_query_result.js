"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.getLinkedTableId = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _field = require("../types/field");

var _error_utils = require("../error_utils");

var _record_query_result = _interopRequireDefault(require("./record_query_result"));

/** @module @airtable/blocks/models: RecordQueryResult */

/** */
var getLinkedTableId = field => {
  var options = field.options;
  var linkedTableId = options && options.linkedTableId;
  (0, _error_utils.invariant)(typeof linkedTableId === 'string', 'linkedTableId must exist');
  return linkedTableId;
};
/** internal */


exports.getLinkedTableId = getLinkedTableId;

/**
 * Represents a set of records from a LinkedRecord cell value. See {@link RecordQueryResult} for main
 * documentation.
 *
 * Do not instantiate. You can get instances of this class by calling
 * `record.selectLinkedRecordsFromCell`.
 *
 * @docsPath models/query results/LinkedRecordsQueryResult
 */
var LinkedRecordsQueryResult =
/*#__PURE__*/
function (_RecordQueryResult) {
  (0, _inherits2.default)(LinkedRecordsQueryResult, _RecordQueryResult);

  /** @internal */
  // the record containing the linked-record cell this is a query of.

  /** @internal */
  // the cell's field in the record

  /** @internal */
  // the table we're linking to

  /** @internal */
  // the records store for the origin table

  /** @internal */
  // the records store for the linked table

  /** @internal */
  // a RecordQueryResult containing all the rows in the linked table

  /** @internal */
  // is the query result currently valid. if the field config changes to link
  // to another table or not be a linked record field at all, isValid will
  // become false. once a LinkedRecordsQueryResult has become invalid, it will
  // not become valid again.

  /** @internal */
  // a lazily-generated set of the record ids in the result set.

  /** @internal */
  // a lazily-generated array of the record ids in the query result.

  /** @internal */
  // how many times has each 'cellValuesInField:$FieldId' been watched?

  /** @internal */

  /** @internal */
  function LinkedRecordsQueryResult(record, field, normalizedOpts, sdk) {
    var _this;

    (0, _classCallCheck2.default)(this, LinkedRecordsQueryResult);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LinkedRecordsQueryResult).call(this, sdk, normalizedOpts));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_record", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_field", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_linkedTable", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_originRecordStore", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_linkedRecordStore", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_linkedQueryResult", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_isValid", true);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_computedRecordIdsSet", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_computedFilteredSortedRecordIds", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_cellValueChangeHandlerByFieldId", {});
    (0, _error_utils.invariant)(record.parentTable === field.parentTable, 'record and field must belong to the same table');
    _this._record = record;
    _this._field = field;
    _this._linkedTable = normalizedOpts.table;
    _this._originRecordStore = _this._sdk.base.__getRecordStore(_this._record.parentTable.id);
    _this._linkedRecordStore = normalizedOpts.recordStore; // we could rely on RecordQueryResult's reuse pool to make sure we get back
    // the same RecordQueryResult every time, but that would make it much harder
    // to make sure we unwatch everything from the old RecordQueryResult if e.g.
    // the field config changes to point at a different table

    _this._linkedQueryResult = _this._linkedTable.__tableOrViewQueryResultPool.getObjectForReuse(_this._sdk, _this._linkedTable, normalizedOpts);
    return _this;
  }
  /**
   * Is the query result currently valid? This value always starts as 'true',
   * but can become false if the record from which this result was created is
   * deleted, if the field is deleted, if the field config changes to link to
   * a different table, or if the field config changes to link to a type
   * other than MULTIPLE_RECORD_LINKS. Once `isValid` has become false, it
   * will never become true again. Many fields will throw on attempting to
   * access them, and watches will no longer fire.
   */


  (0, _createClass2.default)(LinkedRecordsQueryResult, [{
    key: "watch",

    /** @inheritdoc */
    value: function watch(keys, callback, context) {
      (0, _error_utils.invariant)(this.isValid, 'cannot watch an invalid LinkedRecordsQueryResult');
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(LinkedRecordsQueryResult.prototype), "watch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = validKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _key = _step.value;

          if (_key === _record_query_result.default.WatchableKeys.cellValues) {
            this._watchLinkedQueryCellValuesIfNeededAfterWatch();
          }

          if (_key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = _key.substring(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);

            this._watchLinkedQueryCellValuesInFieldIfNeededAfterWatch(fieldId);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return validKeys;
    }
    /** @inheritdoc */

  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var arrayKeys = Array.isArray(keys) ? keys : [keys];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = arrayKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _key2 = _step2.value;

          if (_key2 === _record_query_result.default.WatchableKeys.cellValues) {
            this._unwatchLinkedQueryCellValuesIfPossibleBeforeUnwatch();
          }

          if (_key2.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = _key2.substring(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);

            this._unwatchLinkedQueryCellValuesInFieldIfPossibleBeforeUnwatch(fieldId);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(LinkedRecordsQueryResult.prototype), "unwatch", this).call(this, arrayKeys, callback, context);
    }
    /** @inheritdoc */

  }, {
    key: "loadDataAsync",
    value: function loadDataAsync() {
      return _regenerator.default.async(function loadDataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap((0, _get2.default)((0, _getPrototypeOf2.default)(LinkedRecordsQueryResult.prototype), "loadDataAsync", this).call(this));

            case 2:
              if (this.isDataLoaded) {
                _context.next = 6;
                break;
              }

              _context.next = 5;
              return _regenerator.default.awrap(this.loadDataAsync());

            case 5:
              // there has to be an unloadData call for every loadDataAsync call.
              // call it here to offset calling loadDataAsync a second time
              this.unloadData();

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /** @internal */

  }, {
    key: "_loadDataAsync",
    value: function _loadDataAsync() {
      var initiallyLoaded, changedKeys, fieldIds, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, fieldId;

      return _regenerator.default.async(function _loadDataAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this._record.__linkedRecordsQueryResultPool.registerObjectForReuseStrong(this);

              this._watchOrigin();

              this._watchLinkedQueryResult();

              initiallyLoaded = this._linkedQueryResult.isDataLoaded;
              _context2.next = 6;
              return _regenerator.default.awrap(Promise.all([this._sdk.base.__getRecordStore(this._record.parentTable.id).loadCellValuesInFieldIdsAsync([this._field.id]), this._linkedQueryResult.loadDataAsync(), this._loadRecordColorsAsync()]));

            case 6:
              this._invalidateComputedData();

              changedKeys = ['records', 'recordIds', 'recordColors']; // If the linked query result was not initially loaded, then the
              // `cellValues` event will be emitted via `_onLinkedCellValuesChange`.
              // Otherwise, it must be explicitly included here in order to promote
              // consistency.

              if (initiallyLoaded) {
                changedKeys.push('cellValues');
              }

              fieldIds = this._normalizedOpts.fieldIdsOrNullIfAllFields || this.parentTable.fields.map(field => field.id);
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 13;

              for (_iterator3 = fieldIds[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                fieldId = _step3.value;
                changedKeys.push(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId);
              }

              _context2.next = 21;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](13);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t0;

            case 21:
              _context2.prev = 21;
              _context2.prev = 22;

              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }

            case 24:
              _context2.prev = 24;

              if (!_didIteratorError3) {
                _context2.next = 27;
                break;
              }

              throw _iteratorError3;

            case 27:
              return _context2.finish(24);

            case 28:
              return _context2.finish(21);

            case 29:
              return _context2.abrupt("return", changedKeys);

            case 30:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[13, 17, 21, 29], [22,, 24, 28]]);
    }
    /** @internal */

  }, {
    key: "_unloadData",
    value: function _unloadData() {
      // The inverse of this condition cannot be deterministically reproduced
      // in the testing environment.
      // istanbul ignore else
      if (this.isValid) {
        this._record.__linkedRecordsQueryResultPool.unregisterObjectForReuseStrong(this);

        this._unwatchOrigin();

        this._unwatchLinkedQueryResult();

        this._sdk.base.__getRecordStore(this._record.parentTable.id).unloadCellValuesInFieldIds([this._field.id]);

        this._linkedQueryResult.unloadData();

        this._unloadRecordColors();

        this._invalidateComputedData();
      }
    }
    /**
     * the key used to identify this query result in ObjectPool
     *
     * @hidden
     */

  }, {
    key: "_watchLinkedQueryCellValuesIfNeededAfterWatch",

    /** @internal */
    value: function _watchLinkedQueryCellValuesIfNeededAfterWatch() {
      if (this._cellValuesWatchCount === 1) {
        this._watchLinkedQueryCellValues();
      }
    }
    /** @internal */

  }, {
    key: "_unwatchLinkedQueryCellValuesIfPossibleBeforeUnwatch",
    value: function _unwatchLinkedQueryCellValuesIfPossibleBeforeUnwatch() {
      if (this._cellValuesWatchCount === 1 && this.isValid) {
        this._unwatchLinkedQueryCellValues();
      }
    }
    /** @internal */

  }, {
    key: "_watchLinkedQueryCellValuesInFieldIfNeededAfterWatch",

    /** @internal */
    value: function _watchLinkedQueryCellValuesInFieldIfNeededAfterWatch(fieldId) {
      if (this._cellValueWatchCountByFieldId[fieldId] === 1 && this.isValid) {
        this._watchLinkedQueryCellValuesInField(fieldId);
      }
    }
    /** @internal */

  }, {
    key: "_unwatchLinkedQueryCellValuesInFieldIfPossibleBeforeUnwatch",
    value: function _unwatchLinkedQueryCellValuesInFieldIfPossibleBeforeUnwatch(fieldId) {
      (0, _error_utils.invariant)(this._cellValueWatchCountByFieldId[fieldId], "cellValuesInField:%s over-free'd", fieldId);

      if (this._cellValueWatchCountByFieldId[fieldId] === 1 && this.isValid) {
        this._unwatchLinkedQueryCellValuesInField(fieldId);
      }
    }
    /** @internal */

  }, {
    key: "_watchOrigin",
    value: function _watchOrigin() {
      // if the cell values in the record change, we need to invalidate our
      // cached data and notify watchers
      this._record.watch("cellValueInField:".concat(this._field.id), this._onOriginCellValueChange, this); // if the field config changes, we need to invalidate cached data,
      // and potentially start watching a different table


      this._field.watch('type', this._onOriginFieldConfigChange, this);

      this._field.watch('options', this._onOriginFieldConfigChange, this); // if the underlying record is deleted, we need to invalidate this
      // result


      this._originRecordStore.watch('recordIds', this._onOriginRecordsChange, this); // if the linked field in the origin table is deleted, we need to
      // invalidate this result


      this._record.parentTable.watch('fields', this._onOriginFieldsChange, this);
    }
    /** @internal */

  }, {
    key: "_unwatchOrigin",
    value: function _unwatchOrigin() {
      this._record.unwatch("cellValueInField:".concat(this._field.id), this._onOriginCellValueChange, this);

      this._field.unwatch('type', this._onOriginFieldConfigChange, this);

      this._field.unwatch('options', this._onOriginFieldConfigChange, this);

      this._originRecordStore.unwatch('recordIds', this._onOriginRecordsChange, this);

      this._record.parentTable.unwatch('fields', this._onOriginFieldsChange, this);
    }
    /** @internal */

  }, {
    key: "_watchLinkedQueryResult",
    value: function _watchLinkedQueryResult() {
      // in the linked table, all we care about is the set of recordIds.
      // this watch fire when they're added/removed and when they change
      // order. we only care about order, because add/remove is handled by
      // watching the origin record
      this._linkedQueryResult.watch('recordIds', this._onLinkedRecordIdsChange, this);
    }
    /** @internal */

  }, {
    key: "_unwatchLinkedQueryResult",
    value: function _unwatchLinkedQueryResult() {
      this._linkedQueryResult.unwatch('recordIds', this._onLinkedRecordIdsChange, this);
    }
    /** @internal */

  }, {
    key: "_watchLinkedQueryCellValues",
    value: function _watchLinkedQueryCellValues() {
      this._linkedQueryResult.watch('cellValues', this._onLinkedCellValuesChange, this);
    }
    /** @internal */

  }, {
    key: "_unwatchLinkedQueryCellValues",
    value: function _unwatchLinkedQueryCellValues() {
      this._linkedQueryResult.unwatch('cellValues', this._onLinkedCellValuesChange, this);
    }
    /** @internal */

  }, {
    key: "_watchLinkedQueryCellValuesInField",
    value: function _watchLinkedQueryCellValuesInField(fieldId) {
      this._linkedQueryResult.watch(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, this._getOnLinkedCellValuesInFieldChange(fieldId), this);
    }
    /** @internal */

  }, {
    key: "_unwatchLinkedQueryCellValuesInField",
    value: function _unwatchLinkedQueryCellValuesInField(fieldId) {
      this._linkedQueryResult.unwatch(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, this._getOnLinkedCellValuesInFieldChange(fieldId), this);
    }
    /** @internal */

  }, {
    key: "_onLinkedRecordIdsChange",
    value: function _onLinkedRecordIdsChange() {
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');

      if (!this.isDataLoaded) {
        return;
      }

      this._invalidateComputedData(); // we don't actually know at this stage whether anything changed or
      // not. it may have done though, so notify watchers


      this._onChange('records');

      this._onChange('recordIds');
    }
    /**
     * This model doesn't use the `_data` computed property it inherits from
     * AbstractModel. It implements the following method only so that internal
     * checks for model deletion behave appropriately (the data itself is
     * inconsequential).
     *
     * @internal
     */

  }, {
    key: "_onLinkedCellValuesChange",

    /** @internal */
    value: function _onLinkedCellValuesChange(queryResult, key, changes) {
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');

      if (changes && changes.fieldIds && changes.recordIds) {
        var recordIdsSet = this._getOrGenerateRecordIdsSet();

        var _recordIds = changes.recordIds.filter(id => recordIdsSet[id] === true);

        if (_recordIds.length) {
          this._onChange('cellValues', {
            fieldIds: changes.fieldIds,
            recordIds: _recordIds
          });
        }
      } else {
        this._onChange('cellValues');
      }
    }
    /** @internal */

  }, {
    key: "_getOnLinkedCellValuesInFieldChange",
    value: function _getOnLinkedCellValuesInFieldChange(fieldId) {
      if (!this._cellValueChangeHandlerByFieldId[fieldId]) {
        this._cellValueChangeHandlerByFieldId[fieldId] = (queryResult, key, recordIds) => {
          (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid'); // The linked record may finish loading before its parent. In
          // that case, the appropriate events will be triggered by the
          // `_loadDataAsync` method.

          if (!this.isDataLoaded) {
            return;
          } // The `else` branch will only be reached when the underlying
          // `RecordOrViewQueryResult` is loaded, unloaded, and then
          // loaded again. Because that query result is not directly
          // exposed to consumers, the condition can only be met when the
          // SDK is misused (e.g. repeatedly freeing related query
          // results). The `else` branch attempts to handle that
          // situation in a logical way, but it is not tested because it
          // is fundamentally invalid.
          // istanbul ignore else


          if (Array.isArray(recordIds)) {
            var recordIdsSet = this._getOrGenerateRecordIdsSet();

            var filteredRecordIds = recordIds.filter(id => typeof id === 'string' && recordIdsSet[id] === true);

            if (filteredRecordIds.length) {
              this._onChange(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, filteredRecordIds);
            }
          } else {
            this._onChange(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId);
          }
        };
      }

      return this._cellValueChangeHandlerByFieldId[fieldId];
    }
    /** @internal */

  }, {
    key: "_onOriginCellValueChange",
    value: function _onOriginCellValueChange() {
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');

      if (!this.isDataLoaded) {
        return;
      } // when the origin cell value (listing all the linked records) changes,
      // invalidate all the data we have stored - we need to completely
      // regenerate it


      this._invalidateComputedData(); // notify watchers that our set of linked records has changed


      this._onChange('records');

      this._onChange('recordIds');
    }
    /** @internal */

  }, {
    key: "_onOriginRecordsChange",
    value: function _onOriginRecordsChange() {
      if (this._record.isDeleted) {
        this._isValid = false;
      }
    }
    /** @internal */

  }, {
    key: "_onOriginFieldsChange",
    value: function _onOriginFieldsChange() {
      if (this._field.isDeleted) {
        this._isValid = false;
      }
    }
    /** @internal */

  }, {
    key: "_onOriginFieldConfigChange",
    value: function _onOriginFieldConfigChange() {
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');
      var type = this._field.type;

      if (type !== _field.FieldType.MULTIPLE_RECORD_LINKS) {
        this._invalidateQueryResult();

        return;
      }

      var linkedTableId = getLinkedTableId(this._field);

      if (linkedTableId !== this._linkedTable.id) {
        this._invalidateQueryResult();

        return;
      }
    }
    /** @internal */

  }, {
    key: "_invalidateQueryResult",
    value: function _invalidateQueryResult() {
      if (this.isDataLoaded) {
        this._unloadData();
      }

      if (this._cellValuesWatchCount > 0) {
        this._unwatchLinkedQueryCellValues();
      }

      for (var _i = 0, _Object$keys = Object.keys(this._cellValueWatchCountByFieldId); _i < _Object$keys.length; _i++) {
        var fieldId = _Object$keys[_i];

        this._unwatchLinkedQueryCellValuesInField(fieldId);
      }

      this._isValid = false;

      this._onChange('records');

      this._onChange('recordIds');
    }
    /** @internal */

  }, {
    key: "_invalidateComputedData",
    value: function _invalidateComputedData() {
      this._computedRecordIdsSet = null;
      this._computedFilteredSortedRecordIds = null;
    }
    /** @internal */

  }, {
    key: "_generateComputedDataIfNeeded",
    value: function _generateComputedDataIfNeeded() {
      if (!this._computedRecordIdsSet) {
        this._generateComputedData();
      }
    }
    /** @internal */

  }, {
    key: "_generateComputedData",
    value: function _generateComputedData() {
      var recordIdsSet = {};

      var rawCellValue = this._record.getCellValue(this._field);

      var cellValue = rawCellValue === null ? [] : rawCellValue;
      (0, _error_utils.invariant)(Array.isArray(cellValue), 'cellValue should be array');
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = cellValue[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var linkedRecord = _step4.value;
          (0, _error_utils.invariant)(linkedRecord && typeof linkedRecord === 'object', 'linked record should be object');
          var recordId = linkedRecord.id;
          (0, _error_utils.invariant)(typeof recordId === 'string', 'id should be present'); // We need to use the query result as the source of truth for
          // recordIds, since when the client deletes a record from the linked
          // table, we update it optimistically but the origin cell value
          // doesn't update until receiving the push payload.

          if (this._linkedQueryResult.hasRecord(recordId)) {
            recordIdsSet[recordId] = true;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._computedRecordIdsSet = recordIdsSet;

      if (this._normalizedOpts.sorts && this._normalizedOpts.sorts.length) {
        // when sorts are present, record order comes from the query result
        this._computedFilteredSortedRecordIds = this._linkedQueryResult.recordIds.filter(recordId => recordIdsSet[recordId] === true);
      } else {
        // with no sorts, record order is the same as in the cell in the
        // main Airtable UI. Since we generated recordIdsSet by iterating
        // over the cell value, we're guaranteed that the key order matches
        // the linked record order in the cell.
        this._computedFilteredSortedRecordIds = Object.keys(recordIdsSet);
      }
    }
    /** @internal */

  }, {
    key: "_getOrGenerateRecordIdsSet",
    value: function _getOrGenerateRecordIdsSet() {
      this._generateComputedDataIfNeeded();

      var recordIdsSet = this._computedRecordIdsSet;
      (0, _error_utils.invariant)(recordIdsSet, 'recordIdsSet must exist');
      return recordIdsSet;
    }
  }, {
    key: "isValid",
    get: function get() {
      return this._isValid;
    }
    /**
     * The table that records in this RecordQueryResult are part of
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     */

  }, {
    key: "parentTable",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      return this._linkedTable;
    }
    /**
     * Ordered array of all the linked record ids. Watchable.
     */

  }, {
    key: "recordIds",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      (0, _error_utils.invariant)(this.isDataLoaded, 'LinkedRecordsQueryResult data is not loaded'); // record ids are lazily generated

      this._generateComputedDataIfNeeded();

      (0, _error_utils.invariant)(this._computedFilteredSortedRecordIds, 'no recordIds');
      return this._computedFilteredSortedRecordIds;
    }
    /**
     * Ordered array of all the linked records. Watchable.
     */

  }, {
    key: "records",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      return this.recordIds.map(recordId => {
        var record = this._linkedRecordStore.getRecordByIdIfExists(recordId);

        (0, _error_utils.invariant)(record, 'No record for id: %s', recordId);
        return record;
      });
    }
    /**
     * The fields that were used to create this LinkedRecordsQueryResult.
     */

  }, {
    key: "fields",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      return this._linkedQueryResult.fields;
    }
  }, {
    key: "__poolKey",
    get: function get() {
      return "".concat(this._serializedOpts, "::").concat(this._field.id, "::").concat(this._linkedTable.id, "::").concat(this.isValid);
    }
    /** @internal */

  }, {
    key: "_cellValuesWatchCount",
    get: function get() {
      return (this._changeWatchersByKey[_record_query_result.default.WatchableKeys.cellValues] || []).length;
    }
  }, {
    key: "_cellValueWatchCountByFieldId",
    get: function get() {
      var countByFieldId = {};
      var watchKeys = Object.keys(this._changeWatchersByKey).filter(key => {
        return key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix);
      });
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = watchKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var watchKey = _step5.value;
          var fieldId = watchKey.slice(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);
          countByFieldId[fieldId] = this._changeWatchersByKey[watchKey].length;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return countByFieldId;
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      if (this._record.isDeleted || this._linkedRecordStore.isDeleted) {
        return null;
      }

      return {};
    }
  }]);
  return LinkedRecordsQueryResult;
}(_record_query_result.default);

(0, _defineProperty2.default)(LinkedRecordsQueryResult, "_className", 'LinkedRecordsQueryResult');
var _default = LinkedRecordsQueryResult;
exports.default = _default;