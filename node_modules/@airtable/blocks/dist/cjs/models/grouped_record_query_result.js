"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error_utils = require("../error_utils");

var _record_query_result = _interopRequireDefault(require("./record_query_result"));

var _object_pool = _interopRequireDefault(require("./object_pool"));

/** @module @airtable/blocks/models: RecordQueryResult */

/** */

/**
 * Represents a group of records returned from a group query. See {@link RecordQueryResult} for main
 * documentation.
 *
 * Do not instantiate. You can get instances of this class by calling
 * `recordQueryResult.groups`.
 *
 * @docsPath models/query results/GroupedRecordQueryResult
 * @hidden
 */
var GroupedRecordQueryResult =
/*#__PURE__*/
function (_RecordQueryResult) {
  (0, _inherits2.default)(GroupedRecordQueryResult, _RecordQueryResult);

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * This includes groupLevel for all children & parent grouped layers, the getter
   * returns only the groupLevels for this layer.
   *
   * @internal
   */
  // This is the ordered list of groups.

  /** @internal */
  // lazily generated set of record ids

  /** @internal */
  // lazily generated ordered array of recordIds

  /** @internal */

  /** @internal */
  function GroupedRecordQueryResult(parentQueryResult, groupData, groupLevel, normalizedOpts, sdk) {
    var _this;

    (0, _classCallCheck2.default)(this, GroupedRecordQueryResult);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(GroupedRecordQueryResult).call(this, sdk, normalizedOpts));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_parentQueryResult", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_groupData", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_groupLevels", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_orderedChildrenGroups", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_recordIdsSet", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_orderedRecordIds", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "__groupedRecordQueryResultPool", void 0);
    _this.__groupedRecordQueryResultPool = new _object_pool.default(GroupedRecordQueryResult);
    _this._parentQueryResult = parentQueryResult;
    _this._groupData = groupData;
    _this._groupLevels = groupLevel;

    var groupLevelDataSlicedForChildren = _this._groupLevels.slice(1);

    _this._orderedChildrenGroups = groupData.groups ? groupData.groups.map(singleGroupData => {
      var group = _this.__groupedRecordQueryResultPool.getObjectForReuse((0, _assertThisInitialized2.default)(_this), singleGroupData, groupLevelDataSlicedForChildren, normalizedOpts, sdk); // Don't await the loading, let others check isDataLoaded.
      // (it doesn't take any time anyway). Loading also strong retains.


      group.loadDataAsync();
      return group;
    }) : null;
    return _this;
  }
  /**
   * Gets children groups of this group (if any exist)
   */


  (0, _createClass2.default)(GroupedRecordQueryResult, [{
    key: "_computeRecordIds",

    /**
     * Recursively gets all recordIds in the children groups, keeping recordIds in group order
     *
     * @internal
     */
    value: function _computeRecordIds() {
      // If we are a leaf node, return the raw recordIds
      if (!this.groups) {
        var _this$_data$groupData;

        // Typescript can't infer if groups is empty visibleRecordIds must be populated
        // but the extra safety isn't bad. (istanbul also can't ignore just the ??)
        // istanbul ignore next
        return (_this$_data$groupData = this._data.groupData.visibleRecordIds) !== null && _this$_data$groupData !== void 0 ? _this$_data$groupData : [];
      } // Otherwise build the recordId's from children groups


      var recordIds = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var group = _step.value;
          recordIds.push(...group.recordIds);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return recordIds;
    }
    /**
     * Anytime the recordIds to return could have changed, we clear this so that
     * the next time the user requests recordIds it recomputes
     *
     * @internal
     */

  }, {
    key: "_invalidateComputedRecordIds",
    value: function _invalidateComputedRecordIds() {
      this._orderedRecordIds = null;
    }
    /**
     * Ordered array of all the record ids inside this group, in group order.
     * This returns all recordIds of all children groups (in grouped order).
     * Watchable.
     */

  }, {
    key: "watch",

    /** @inheritdoc */
    value: function watch(keys, callback, context) {
      // TODO (SeanKeenan): This provides events even if they occur outside of this group
      // This is an issue that needs to be fixed before this API is made public
      var validKeys = this._parentQueryResult.watch(keys, callback, context);

      return validKeys;
    }
    /** @inheritdoc */

  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      return this._parentQueryResult.unwatch(keys, callback, context);
    }
    /** @inheritdoc */

  }, {
    key: "loadDataAsync",
    value: function loadDataAsync() {
      return _regenerator.default.async(function loadDataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap((0, _get2.default)((0, _getPrototypeOf2.default)(GroupedRecordQueryResult.prototype), "loadDataAsync", this).call(this));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /** @internal */

  }, {
    key: "_getChangedKeysOnLoad",
    value: function _getChangedKeysOnLoad() {
      return this._parentQueryResult._getChangedKeysOnLoad();
    }
    /** @internal */

  }, {
    key: "_loadDataAsync",
    value: function _loadDataAsync() {
      return _regenerator.default.async(function _loadDataAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this._parentQueryResult.__groupedRecordQueryResultPool.registerObjectForReuseStrong(this); // Ensure we invalidate our memoized computed recordIds whenever a relevant hook changes
              // TODO: (SeanKeenan) At the moment this should never be relevant, because groups are recreated
              // anytime the groups change - but this is how it should work once groups persist AND
              // watching recordIds only changes if records in this group change.
              // In the meantime this does ensure that a deleted GroupedRecordQuery with stale recordIds
              // doesn't return the cached array.


              this.watch(['recordIds', 'groups', 'groupLevels'], this._invalidateComputedRecordIds, this);
              this.watch(['recordIds'], this._invalidateRecordIdsSet, this);
              return _context2.abrupt("return", this._getChangedKeysOnLoad());

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /** @internal */

  }, {
    key: "_unloadData",
    value: function _unloadData() {
      // Ensure we invalidate our memoized computed recordIds whenever a relevant hook changes
      this.unwatch(['recordIds', 'groups', 'groupLevels'], this._invalidateComputedRecordIds, this);
      this.unwatch(['recordIds'], this._invalidateRecordIdsSet, this); // Invalidate both of the caches, as this object can no longer be accessed

      this._invalidateComputedRecordIds();

      this._invalidateRecordIdsSet();

      this._unloadChildrenGroupsIfNeeded();

      this._parentQueryResult.__groupedRecordQueryResultPool.unregisterObjectForReuseStrong(this);
    }
    /** @internal */

  }, {
    key: "_unloadChildrenGroupsIfNeeded",

    /** @internal */
    value: function _unloadChildrenGroupsIfNeeded() {
      if (this._orderedChildrenGroups) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._orderedChildrenGroups[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var group = _step2.value;
            group.unloadData();
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
    /** @internal */

  }, {
    key: "_invalidateRecordIdsSet",
    value: function _invalidateRecordIdsSet() {
      this._recordIdsSet = null;
    }
    /** @internal */

  }, {
    key: "_getOrGenerateRecordIdsSet",
    value: function _getOrGenerateRecordIdsSet() {
      // TODO (SeanKeenan): this logic is duplicated in tableOrViewQueryResult
      if (!this._recordIdsSet) {
        var recordIdsSet = {};
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.recordIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var recordId = _step3.value;
            recordIdsSet[recordId] = true;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        this._recordIdsSet = recordIdsSet;
      }

      return this._recordIdsSet;
    }
  }, {
    key: "groups",
    get: function get() {
      return this._orderedChildrenGroups;
    }
    /** @internal */

  }, {
    key: "groupLevel",
    get: function get() {
      return this._data.groupLevels[0];
    }
    /**
     * Gets the fieldId that this group is grouped by
     */

  }, {
    key: "fieldId",
    get: function get() {
      return this.groupLevel.fieldId;
    }
    /**
     * Gets the field that this group is grouped by
     */

  }, {
    key: "field",
    get: function get() {
      return this.parentTable.getFieldById(this.fieldId);
    } // TODO (SeanKeenan) This is needed because we can't always iterate down and find
    // a record, it's possible to have "empty groups".
    // getValue() {
    // }
    // TODO (SeanKeenan)
    // getValueAsString() {
    // }

    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The table that records in this RecordQueryResult are part of
     */

  }, {
    key: "parentTable",
    get: function get() {
      return this._parentQueryResult.parentTable;
    }
  }, {
    key: "recordIds",
    get: function get() {
      (0, _error_utils.invariant)(this.isDataLoaded, 'GroupedRecordQueryResult data is not loaded');

      if (this._orderedRecordIds === null) {
        this._orderedRecordIds = this._computeRecordIds();
      }

      return this._orderedRecordIds;
    }
    /**
     * The fields that were used to create the parent RecordQueryResult that created this GroupedRecordQueryResult.
     * This is separate from the field/fieldId property - which is the field this grouping is based upon.
     * Null if fields were not specified, which means the RecordQueryResult
     * will load all fields in the table.
     */

  }, {
    key: "fields",
    get: function get() {
      (0, _error_utils.invariant)(this.isDataLoaded, 'GroupedRecordQueryResult data is not loaded');
      return this._parentQueryResult.fields;
    }
  }, {
    key: "__poolKey",
    get: function get() {
      // TODO (SeanKeenan) We don't have an actual groupId, but while id is unique; this should have id removed
      return "".concat(this._serializedOpts, "::").concat(this.id);
    }
    /**
     * This model doesn't actually load data, but it does use the `_data`
     * property so that checks for model deletion behave appropriately.
     *
     * This is considered deleted if the parent query result has been deleted.
     *
     * We return groupData, instead of precomputing all children groups because
     * we perform the computation+caching lazily on request
     *
     * @internal
     */

  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      if (this._parentQueryResult._dataOrNullIfDeleted === null) {
        return null;
      }

      return {
        groupData: this._groupData,
        groupLevels: this._groupLevels
      };
    }
    /** @inheritdoc */

  }, {
    key: "isDataLoaded",
    get: function get() {
      return this._parentQueryResult.isDataLoaded;
    }
  }]);
  return GroupedRecordQueryResult;
}(_record_query_result.default);

(0, _defineProperty2.default)(GroupedRecordQueryResult, "_className", 'GroupedRecordQueryResult');
var _default = GroupedRecordQueryResult;
exports.default = _default;