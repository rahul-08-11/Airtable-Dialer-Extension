"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.flat-map");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.unscopables.flat-map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/es.string.includes");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.url.to-json");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _airtable_interface = require("../types/airtable_interface");

var _mutations = require("../types/mutations");

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _mutation_constants = require("./mutation_constants");

// Limit for how many items can be updated from a single batch mutation.
// This is number of records for MULTIPLE_RECORDS type mutations, and number of global config paths
// for SET_MULTIPLE_GLOBAL_CONFIG_PATHS.
// Same limit is enforced liveapp-side
var MUTATIONS_MAX_BATCH_SIZE = 50; // Liveapp requests must be under 2mb in size: we enforce a 1.9mb limit here to allow space for
// the other parts of the request

var MUTATIONS_MAX_BODY_SIZE = 1.9 * 1024 * 1024;
var MUTATION_HOLD_FOR_MS = 100;
/** @internal */

var Mutations =
/*#__PURE__*/
function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @hidden */
  function Mutations(sdk, session, base, applyModelChanges, applyGlobalConfigUpdates) {
    (0, _classCallCheck2.default)(this, Mutations);
    (0, _defineProperty2.default)(this, "_airtableInterface", void 0);
    (0, _defineProperty2.default)(this, "_session", void 0);
    (0, _defineProperty2.default)(this, "_sdk", void 0);
    (0, _defineProperty2.default)(this, "_base", void 0);
    (0, _defineProperty2.default)(this, "_applyModelChanges", void 0);
    (0, _defineProperty2.default)(this, "_applyGlobalConfigUpdates", void 0);
    this._airtableInterface = sdk.__airtableInterface;
    this._session = session;
    this._sdk = sdk;
    this._base = base;
    this._applyModelChanges = applyModelChanges;
    this._applyGlobalConfigUpdates = applyGlobalConfigUpdates;
  }
  /** @hidden */


  (0, _createClass2.default)(Mutations, [{
    key: "applyMutationAsync",
    value: function applyMutationAsync(mutation) {
      var permissionCheck, didApplyOptimisticUpdates;
      return _regenerator.default.async(function applyMutationAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._assertMutationIsValid(mutation); // Limit check is after validity check so that we display errors for when users pass in
              // objects correctly (eg updating linked records cell value to be a record object) -
              // otherwise the limit check will fail due to circular objects being converted to JSON first


              this._assertMutationUnderLimits(mutation);

              permissionCheck = this.checkPermissionsForMutation(mutation);

              if (permissionCheck.hasPermission) {
                _context.next = 5;
                break;
              }

              throw (0, _error_utils.spawnError)('Cannot apply %s mutation: %s', mutation.type, permissionCheck.reasonDisplayString);

            case 5:
              didApplyOptimisticUpdates = this._applyOptimisticUpdatesForMutation(mutation);
              _context.prev = 6;
              _context.next = 9;
              return _regenerator.default.awrap(this._airtableInterface.applyMutationAsync(mutation, {
                holdForMs: MUTATION_HOLD_FOR_MS
              }));

            case 9:
              _context.next = 20;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](6);

              if (!didApplyOptimisticUpdates) {
                _context.next = 19;
                break;
              }

              // if we applied optimistic updates, we can't gracefully handle a promise rejection
              // here - we can't un-apply optimistic updates, so the SDK's internal data model is
              // in an unexpected state. Instead of letting this promise get rejected, throw an
              // error after an async gap to crash the block, and make this promise await
              // something that will never resolve so we don't run any of the developers error-
              // handling code.
              setTimeout(() => {
                throw _context.t0;
              }, 0);
              _context.next = 17;
              return _regenerator.default.awrap(new Promise(() => {}));

            case 17:
              _context.next = 20;
              break;

            case 19:
              throw _context.t0;

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[6, 11]]);
    }
    /** @hidden */

  }, {
    key: "checkPermissionsForMutation",
    value: function checkPermissionsForMutation(mutation) {
      return this._airtableInterface.checkPermissionsForMutation(mutation, this._base.__getBaseData());
    }
    /** @internal */

  }, {
    key: "_assertMutationUnderLimits",
    value: function _assertMutationUnderLimits(mutation) {
      // Two limits to check here:
      // - for record-related mutations, it isn't above MUTATIONS_MAX_BATCH_SIZE
      // - mutation payload size won't exceed liveapp request payload size limit
      // Requests are sent as form-encoded utf-8 (1 byte characters)
      if (encodeURIComponent(JSON.stringify(mutation)).length > MUTATIONS_MAX_BODY_SIZE) {
        throw (0, _error_utils.spawnError)('Request exceeds maximum size limit of %s bytes', MUTATIONS_MAX_BODY_SIZE);
      }

      if (this._doesMutationExceedBatchSizeLimit(mutation)) {
        throw (0, _error_utils.spawnError)('Request exceeds maximum batch size limit of %s items', MUTATIONS_MAX_BATCH_SIZE);
      }
    }
    /** @internal */

  }, {
    key: "_doesMutationExceedBatchSizeLimit",
    value: function _doesMutationExceedBatchSizeLimit(mutation) {
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          return mutation.records.length > MUTATIONS_MAX_BATCH_SIZE;

        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          return mutation.recordIds.length > MUTATIONS_MAX_BATCH_SIZE;

        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          return mutation.updates.length > MUTATIONS_MAX_BATCH_SIZE;
        // The "default" case cannot be reached because this method is only
        // invoked after the mutation type has been validated.
        // istanbul ignore next

        default:
          return false;
      }
    }
    /** @internal */

  }, {
    key: "_assertFieldIsValidForMutation",
    value: function _assertFieldIsValidForMutation(field) {
      if (field.isComputed) {
        throw (0, _error_utils.spawnError)("Can't set cell values: Field '%s' is computed and cannot be set", field.name);
      }
    }
    /** @internal */

  }, {
    key: "_assertMutationIsValid",
    value: function _assertMutationIsValid(mutation) {
      // We call validate the data (including any cell values) because if the data required for
      // us to do that is already loaded in the block, we can error out before applying
      // optimistic updates or sending the update to liveapp. That means that the error is
      // recoverable. Once we apply optimistic updates, if liveapp rejects the update then we
      // can't recover from that - we have to crash the block. We _could_ skip over these
      // validations - it wouldn't cause issues outside of the block frame. But running them
      // gives us slightly more confidence that we can do something other than completely crash
      // the block in the event of an invalid mutation.
      var appInterface = this._sdk.__appInterface;
      var billingPlanGrouping = this._base.__billingPlanGrouping;

      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
          {
            var tableId = mutation.tableId,
                records = mutation.records;

            var table = this._base.getTableByIdIfExists(tableId);

            if (!table) {
              throw (0, _error_utils.spawnError)("Can't set cell values: No table with id %s exists", tableId);
            } // For every mutation, we check that we're not trying to set fields that we don't support
            // mutations for yet. When record data is loaded, we also check that the record we're
            // updating actually exists and that the cell values are valid.


            var recordStore = this._base.__getRecordStore(tableId);

            var checkedFieldIds = new Set();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = records[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var record = _step.value;
                var existingRecord = null;

                if (recordStore.isRecordMetadataLoaded) {
                  existingRecord = recordStore.getRecordByIdIfExists(record.id);

                  if (!existingRecord) {
                    throw (0, _error_utils.spawnError)("Can't set cell values: No record with id %s exists", record.id);
                  }
                }

                for (var _i = 0, _Object$keys = Object.keys(record.cellValuesByFieldId); _i < _Object$keys.length; _i++) {
                  var fieldId = _Object$keys[_i];
                  var field = table.getFieldByIdIfExists(fieldId);

                  if (!field) {
                    throw (0, _error_utils.spawnError)("Can't set cell values: No field with id %s exists in table '%s'", fieldId, table.name);
                  }

                  if (!checkedFieldIds.has(fieldId)) {
                    this._assertFieldIsValidForMutation(field);

                    checkedFieldIds.add(fieldId);
                  }

                  if (existingRecord && recordStore.areCellValuesLoadedForFieldId(fieldId)) {
                    var validationResult = this._airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, record.cellValuesByFieldId[fieldId], existingRecord._getRawCellValue(field), field._data);

                    if (!validationResult.isValid) {
                      throw (0, _error_utils.spawnError)("Can't set cell values: invalid cell value for field '%s'.\n%s", field.name, validationResult.reason);
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return;
          }

        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          {
            var _tableId = mutation.tableId,
                recordIds = mutation.recordIds;

            var _table = this._base.getTableByIdIfExists(_tableId);

            if (!_table) {
              throw (0, _error_utils.spawnError)("Can't delete records: No table with id %s exists", _tableId);
            }

            var _recordStore = this._base.__getRecordStore(_tableId);

            if (_recordStore.isRecordMetadataLoaded) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = recordIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var recordId = _step2.value;

                  var _record = _recordStore.getRecordByIdIfExists(recordId);

                  if (!_record) {
                    throw (0, _error_utils.spawnError)("Can't delete records: No record with id %s exists in table '%s'", recordId, _table.name);
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }

            return;
          }

        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          {
            var _tableId2 = mutation.tableId,
                _records = mutation.records;

            var _checkedFieldIds = new Set();

            var _table2 = this._base.getTableByIdIfExists(_tableId2);

            if (!_table2) {
              throw (0, _error_utils.spawnError)("Can't create records: No table with id %s exists", _tableId2);
            }

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = _records[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _record2 = _step3.value;

                for (var _i2 = 0, _Object$keys2 = Object.keys(_record2.cellValuesByFieldId); _i2 < _Object$keys2.length; _i2++) {
                  var _fieldId = _Object$keys2[_i2];

                  var _field = _table2.getFieldByIdIfExists(_fieldId);

                  if (!_field) {
                    throw (0, _error_utils.spawnError)("Can't create records: No field with id %s exists in table '%s'", _fieldId, _table2.name);
                  }

                  if (!_checkedFieldIds.has(_fieldId)) {
                    this._assertFieldIsValidForMutation(_field);

                    _checkedFieldIds.add(_fieldId);
                  } // Current cell value is null since the record doesn't exist.


                  var _validationResult = this._airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, _record2.cellValuesByFieldId[_fieldId], null, _field._data);

                  if (!_validationResult.isValid) {
                    throw (0, _error_utils.spawnError)("Can't create records: invalid cell value for field '%s'.\n%s", _field.name, _validationResult.reason);
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            return;
          }

        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          {
            // globalConfig update is a special case: globalConfig handles validation before
            // invoking this mutation, since it relies on internal state to validate the
            // paths being set.
            return;
          }

        case _mutations.MutationTypes.CREATE_SINGLE_FIELD:
          {
            var _tableId3 = mutation.tableId,
                name = mutation.name,
                config = mutation.config;

            var _table3 = this._base.getTableByIdIfExists(_tableId3);

            if (!_table3) {
              throw (0, _error_utils.spawnError)("Can't create field: No table with id %s exists", _tableId3);
            }

            if (_table3.fields.length >= _mutation_constants.MAX_NUM_FIELDS_PER_TABLE) {
              throw (0, _error_utils.spawnError)("Can't create field: table already has the maximum of %s fields", _mutation_constants.MAX_NUM_FIELDS_PER_TABLE);
            }

            if (!name) {
              throw (0, _error_utils.spawnError)("Can't create field: must provide non-empty name");
            }

            if (name.length > _mutation_constants.MAX_FIELD_NAME_LENGTH) {
              throw (0, _error_utils.spawnError)("Can't create field: name '%s' exceeds maximum length of %s characters", name, _mutation_constants.MAX_FIELD_NAME_LENGTH);
            }

            var existingLowercaseFieldNames = _table3.fields.map(field => field.name.toLowerCase());

            if (existingLowercaseFieldNames.includes(name.toLowerCase())) {
              throw (0, _error_utils.spawnError)("Can't create field: field with name '%s' already exists", name);
            } // Current config / field data is null since the field doesn't exist.


            var _validationResult2 = this._airtableInterface.fieldTypeProvider.validateConfigForUpdate(appInterface, config, null, null, billingPlanGrouping);

            if (!_validationResult2.isValid) {
              throw (0, _error_utils.spawnError)("Can't create field: invalid field config.\n%s", _validationResult2.reason);
            }

            return;
          }

        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG:
          {
            var _tableId4 = mutation.tableId,
                id = mutation.id,
                _config = mutation.config,
                opts = mutation.opts;

            var _table4 = this._base.getTableByIdIfExists(_tableId4);

            if (!_table4) {
              throw (0, _error_utils.spawnError)("Can't update field: No table with id %s exists", _tableId4);
            }

            var _field2 = _table4.getFieldByIdIfExists(id);

            if (!_field2) {
              throw (0, _error_utils.spawnError)("Can't update field: No field with id %s exists", id);
            } // we get the config directly instead of using field.type/field.options to get it
            // in one call and because field.options returns null instead of undefined when
            // a field does not have options, whilst we need to pass undefined


            var currentConfig = this._airtableInterface.fieldTypeProvider.getConfig(appInterface, _field2._data, _field2.parentTable.__getFieldNamesById());

            var _validationResult3 = this._airtableInterface.fieldTypeProvider.validateConfigForUpdate(appInterface, _config, currentConfig, _field2._data, billingPlanGrouping, opts);

            if (!_validationResult3.isValid) {
              throw (0, _error_utils.spawnError)("Can't update field: invalid field config.\n%s", _validationResult3.reason);
            }

            return;
          }

        case _mutations.MutationTypes.CREATE_SINGLE_TABLE:
          {
            var _name = mutation.name,
                fields = mutation.fields;

            if (!_name) {
              throw (0, _error_utils.spawnError)("Can't create table: must provide non-empty name");
            }

            if (_name.length > _mutation_constants.MAX_TABLE_NAME_LENGTH) {
              throw (0, _error_utils.spawnError)("Can't create table: name '%s' exceeds maximum length of %s characters", _name, _mutation_constants.MAX_TABLE_NAME_LENGTH);
            }

            var existingLowercaseTableNames = this._base.tables.map(table => table.name.toLowerCase());

            if (existingLowercaseTableNames.includes(_name.toLowerCase())) {
              throw (0, _error_utils.spawnError)("Can't create table: table with name '%s' already exists", _name);
            }

            if (fields.length === 0) {
              throw (0, _error_utils.spawnError)("Can't create table: must specify at least one field");
            }

            if (fields.length > _mutation_constants.MAX_NUM_FIELDS_PER_TABLE) {
              throw (0, _error_utils.spawnError)("Can't create table: number of fields exceeds maximum of %s", _mutation_constants.MAX_NUM_FIELDS_PER_TABLE);
            }

            var lowercaseFieldNames = new Set();
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = fields[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var _field3 = _step4.value;

                if (!_field3.name) {
                  throw (0, _error_utils.spawnError)("Can't create table: must provide non-empty name for every field");
                }

                if (_field3.name.length > _mutation_constants.MAX_FIELD_NAME_LENGTH) {
                  throw (0, _error_utils.spawnError)("Can't create table: field name '%s' exceeds maximum length of %s characters", _field3.name, _mutation_constants.MAX_FIELD_NAME_LENGTH);
                }

                var lowercaseFieldName = _field3.name.toLowerCase();

                if (lowercaseFieldNames.has(lowercaseFieldName)) {
                  throw (0, _error_utils.spawnError)("Can't create table: duplicate field name '%s'", _field3.name);
                }

                lowercaseFieldNames.add(lowercaseFieldName); // Current config / field data is null since the field doesn't exist.

                var _validationResult4 = this._airtableInterface.fieldTypeProvider.validateConfigForUpdate(appInterface, _field3.config, null, null, billingPlanGrouping);

                if (!_validationResult4.isValid) {
                  throw (0, _error_utils.spawnError)("Can't create table: invalid field config for field '%s'.\n%s", _field3.name, _validationResult4.reason);
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            var primaryField = fields[0];

            if (!this._airtableInterface.fieldTypeProvider.canBePrimary(appInterface, primaryField.config, billingPlanGrouping)) {
              throw (0, _error_utils.spawnError)("Can't create table: first field '%s' has type '%s' which cannot be a primary field", primaryField.name, primaryField.config.type);
            }

            return;
          }

        case _mutations.MutationTypes.UPDATE_VIEW_METADATA:
          {
            var _tableId5 = mutation.tableId,
                viewId = mutation.viewId;
            var runContext = this._airtableInterface.sdkInitData.runContext;

            if (runContext.type !== _airtable_interface.BlockRunContextType.VIEW) {
              throw (0, _error_utils.spawnError)('Setting view metadata is only valid for views');
            }

            if (runContext.viewId !== viewId || runContext.tableId !== _tableId5) {
              throw (0, _error_utils.spawnError)('Custom views can only set view metadata on themselves');
            }

            var _table5 = this._base.getTableByIdIfExists(_tableId5);

            if (!_table5) {
              throw (0, _error_utils.spawnError)("Can't update metadata: No table with id %s exists", _tableId5);
            }

            var view = _table5.getViewByIdIfExists(viewId);

            if (!view) {
              throw (0, _error_utils.spawnError)("Can't update metadata: No view with id %s exists", viewId);
            }

            return;
          }

        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('mutation type', mutation, 'type');
      }
    }
    /** @internal */

  }, {
    key: "_applyOptimisticUpdatesForMutation",
    value: function _applyOptimisticUpdatesForMutation(mutation) {
      // GlobalConfig updates are different to other mutations (on models): for models, we
      // only apply optimistic updates if the relevant models are loaded, whereas for
      // SET_MULTIPLE_GLOBAL_CONFIG_PATHS we always apply optimistic updates.
      if (mutation.type === _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS) {
        this._applyGlobalConfigUpdates(mutation.updates);

        return true;
      }

      var modelChanges = this._getOptimisticModelChangesForMutation(mutation);

      if (modelChanges.length > 0) {
        this._applyModelChanges(modelChanges);

        return true;
      }

      return false;
    }
    /** @internal */

  }, {
    key: "_getOptimisticModelChangesForMutation",
    value: function _getOptimisticModelChangesForMutation(mutation) {
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
          {
            var tableId = mutation.tableId,
                records = mutation.records;

            var recordStore = this._base.__getRecordStore(tableId);

            return records.flatMap(record => Object.keys(record.cellValuesByFieldId).filter(fieldId => recordStore.areCellValuesLoadedForFieldId(fieldId)).map(fieldId => ({
              path: ['tablesById', tableId, 'recordsById', record.id, 'cellValuesByFieldId', fieldId],
              value: record.cellValuesByFieldId[fieldId]
            })));
          }

        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          {
            var _tableId6 = mutation.tableId,
                recordIds = mutation.recordIds;

            var _recordStore2 = this._base.__getRecordStore(_tableId6);

            if (!_recordStore2.isRecordMetadataLoaded) {
              return [];
            }

            return [...recordIds.map(recordId => ({
              path: ['tablesById', _tableId6, 'recordsById', recordId],
              value: undefined
            })), ...this._base.getTableById(_tableId6).views.flatMap(view => {
              var viewDataStore = _recordStore2.getViewDataStore(view.id);

              if (!viewDataStore.isDataLoaded) {
                return [];
              }

              return viewDataStore.__generateChangesForParentTableDeleteMultipleRecords(recordIds);
            })];
          }

        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          {
            var _tableId7 = mutation.tableId,
                _records2 = mutation.records;

            var _recordStore3 = this._base.__getRecordStore(_tableId7);

            if (!_recordStore3.isRecordMetadataLoaded) {
              return [];
            }

            return [..._records2.map(record => {
              // Only apply optimistic changes for fields that are loaded
              var filteredCellValuesByFieldId = {};
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = (0, _private_utils.entries)(record.cellValuesByFieldId)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var _step5$value = (0, _slicedToArray2.default)(_step5.value, 2),
                      fieldId = _step5$value[0],
                      cellValue = _step5$value[1];

                  if (_recordStore3.areCellValuesLoadedForFieldId(fieldId)) {
                    filteredCellValuesByFieldId[fieldId] = cellValue;
                  }
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              return {
                path: ['tablesById', _tableId7, 'recordsById', record.id],
                value: {
                  id: record.id,
                  cellValuesByFieldId: filteredCellValuesByFieldId,
                  commentCount: 0,
                  createdTime: new Date().toJSON()
                }
              };
            }), ...this._base.getTableById(_tableId7).views.flatMap(view => {
              var viewDataStore = _recordStore3.getViewDataStore(view.id);

              if (!viewDataStore.isDataLoaded) {
                return [];
              }

              return viewDataStore.__generateChangesForParentTableAddMultipleRecords(_records2.map(record => record.id));
            })];
          }
        // The following branch is unreachable because this method's only
        // call site is preceded by an explicit guard for this condition.
        // istanbul ignore next

        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          {
            throw (0, _error_utils.spawnError)('attempting to generate model updates for SET_MULTIPLE_GLOBAL_CONFIG_PATH');
          }

        case _mutations.MutationTypes.CREATE_SINGLE_FIELD:
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG:
        case _mutations.MutationTypes.UPDATE_VIEW_METADATA:
        case _mutations.MutationTypes.CREATE_SINGLE_TABLE:
          {
            // No optimistic updates for field, view metadata, or table mutations.
            return [];
          }
        // The following branch is unreachable because this method's only
        // call site is preceded by an explicit guard for this condition.
        // istanbul ignore next

        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('mutation type', mutation, 'type');
      }
    }
  }]);
  return Mutations;
}();

var _default = Mutations;
exports.default = _default;